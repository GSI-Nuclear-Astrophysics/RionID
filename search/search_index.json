{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RionID (Ring-stored ion IDentification)","text":"<p>RionID is a Python software for the identification of ions stored in storage rings. It simulates revolution frequencies based on magnetic rigidity or frequency settings and matches them against experimental Schottky spectra.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pure Python: No ROOT dependencies required.</li> <li>Automated Matching: Includes Quick PID logic to scan $\\alpha_p$ and Reference Frequency to find the best match ($\\chi^2$ minimization).</li> <li>Signal Processing: Built-in baseline subtraction (BrPLS) and peak detection.</li> <li>Standalone: Bundles <code>barion</code> and <code>lisereader</code> (GPL-3.0) for easy installation without complex dependency management.</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#option-1-from-pypi-recommended","title":"Option 1: From PyPI (Recommended)","text":"<p>RionID is available on the Python Package Index. This is the easiest way to install it along with all dependencies.</p> <pre><code>pip install rionid\n</code></pre>"},{"location":"#option-2-from-source","title":"Option 2: From Source","text":"<p>If you want the development version:</p> <pre><code>git clone https://github.com/GSI-Nuclear-Astrophysics/rionid.git\ncd rionid\npip install .\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#graphical-user-interface-gui","title":"Graphical User Interface (GUI)","text":"<p>Once installed, you can launch the GUI simply by typing:</p> <pre><code>rionid\n</code></pre>"},{"location":"#command-line-interface-cli","title":"Command Line Interface (CLI)","text":"<p>You can also run simulations directly from the terminal:</p> <pre><code>rionid datafile.npz -f 11.2452 -r 209Bi+83 -psim fragments.lpp -b 5.5\n</code></pre>"},{"location":"#arguments","title":"Arguments","text":"<ul> <li><code>datafile</code>: Input spectrum file (.npz, .csv, .txt).</li> <li><code>-r</code>, <code>--refion</code>: Reference ion (e.g., <code>72Ge+35</code>).</li> <li><code>-ap</code>, <code>--alphap</code>: Momentum compaction factor.</li> <li><code>-psim</code>: LISE++ output file for fragment yields.</li> <li><code>-hrm</code>: Harmonics to simulate.</li> <li><code>-b</code>, <code>--brho</code>: Magnetic rigidity (Brho) [Tm].</li> <li><code>-f</code>, <code>--fref</code>: Revolution frequency [Hz].</li> <li><code>--remove_baseline</code>: Apply baseline subtraction.</li> <li><code>--peak_threshold_pct</code>: Peak detection threshold (0.0 - 1.0).</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Dr. RuiJiu Chen for providing the C++ Time-of-Flight simulation code that inspired the backbone of this software.</li> <li>Dr. Shahab Sanjari for guidance on software architecture and Schottky analysis.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0. See the LICENSE file for details. ```</p>"},{"location":"reference/rionid/","title":"Index","text":""},{"location":"reference/rionid/#rionid","title":"<code>rionid</code>","text":""},{"location":"reference/rionid/__main__/","title":"main","text":""},{"location":"reference/rionid/__main__/#rionid.__main__","title":"<code>rionid.__main__</code>","text":""},{"location":"reference/rionid/__main__/#rionid.__main__.display_nions","title":"<code>display_nions(nions, yield_data, nuclei_names, simulated_data_dict, ref_ion, harmonics)</code>","text":"<p>Filters the top N ions by yield.</p> Source code in <code>src/rionid/__main__.py</code> <pre><code>def display_nions(nions, yield_data, nuclei_names, simulated_data_dict, ref_ion, harmonics):\n    \"\"\"Filters the top N ions by yield.\"\"\"\n    sorted_indices = argsort(yield_data)[::-1][:nions]\n    ref_index = where(nuclei_names == ref_ion)[0]\n\n    # Ensure reference ion is always included\n    if len(ref_index) &gt; 0 and ref_index[0] not in sorted_indices:\n        sorted_indices = append(sorted_indices, ref_index)\n\n    nuclei_names = nuclei_names[sorted_indices]\n\n    for harmonic in harmonics: \n        name = f'{harmonic}'\n        if name in simulated_data_dict:\n            simulated_data_dict[name] = simulated_data_dict[name][sorted_indices]\n</code></pre>"},{"location":"reference/rionid/__main__/#rionid.__main__.main","title":"<code>main()</code>","text":"<p>Main entry point for the command-line interface (CLI).</p> <p>Parses arguments, initializes logging, and dispatches the analysis controller for one or more data files.</p> Source code in <code>src/rionid/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Main entry point for the command-line interface (CLI).\n\n    Parses arguments, initializes logging, and dispatches the analysis controller\n    for one or more data files.\n    \"\"\"\n    scriptname = 'RionID' \n    parser = argparse.ArgumentParser(description=\"RionID: Ring-stored ion Identification\")\n    modes = parser.add_mutually_exclusive_group(required=True)\n\n    # Main Arguments\n    parser.add_argument('datafile', type=str, nargs='+', help='Name of the input file with data.')\n    parser.add_argument('-ap', '--alphap', type=float, help='Momentum compaction factor of the ring.')\n    parser.add_argument('-r', '--refion', type=str, help='Reference ion (Format: AAXX+CC, e.g., 72Ge+35).')\n    parser.add_argument('-psim', '--filep', type=str, help='Path to particle list file (LISE++ output).')\n    parser.add_argument('-hrm', '--harmonics', type=float, default=[1.0], nargs='+', help='Harmonics to simulate.')\n\n    # Secondary Arguments\n    parser.add_argument('-n', '--nions', type=int, help='Number of ions to display, sorted by yield.')\n\n    # Arguments for Each Mode (Exclusive)\n    modes.add_argument('-b', '--brho', type=float, help='Brho value [Tm] (Isochronous mode).')\n    modes.add_argument('-ke', '--kenergy', type=float, help='Kinetic energy [MeV/u] (Isochronous mode).')\n    modes.add_argument('-gam', '--gamma', type=float, help='Lorentz factor gamma.')\n    modes.add_argument('-f', '--fref', type=float, help='Revolution frequency [Hz] (Standard mode).')\n\n    # Visualization &amp; Output\n    parser.add_argument('-d', '--ndivs', type=int, default=4, help='Number of divisions (Deprecated).')\n    parser.add_argument('-am', '--amplitude', type=int, default=0, help='Display options (0=const, else=scaled).')\n    parser.add_argument('-l', '--log', dest='logLevel', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'], default='INFO', help='Set logging level.')\n    parser.add_argument('-s', '--show', help='Show display.', action='store_true')\n    parser.add_argument('-w', '--ods', help='Write output to ODS file.', action='store_true')\n    parser.add_argument('-o', '--outdir', type=str, nargs='?', default=os.getcwd(), help='Output directory.')\n    parser.add_argument('-c', '--correct', nargs='*', type=float, help='Polynomial correction parameters (a0, a1, a2).')\n\n    args = parser.parse_args()\n\n    # Argument Validation\n    if args.brho is None and args.fref is None and args.kenergy is None and args.gamma is None:\n        parser.error('You must provide one reference parameter: -f, -b, -ke, or -gam.')\n\n    # Logging Setup\n    if args.logLevel: \n        log.basicConfig(level=log.getLevelName(args.logLevel))\n\n    # Handle alphap conversion\n    if args.alphap and args.alphap &gt; 1: \n        args.alphap = 1 / args.alphap**2\n\n    print(f'Running {scriptname}...')\n    log.info(f'Processing {args.datafile} for reference {args.refion}.')\n\n    # Handle file lists vs single files\n    files_to_process = []\n    if 'txt' in args.datafile[0] and len(args.datafile) == 1:\n        files_to_process = read_masterfile(args.datafile[0])\n    else:\n        files_to_process = args.datafile\n\n    # Initialize Qt Application ONCE (Crucial for loops)\n    app = None\n    if args.show:\n        app = QApplication.instance()\n        if not app:\n            app = QApplication(sys.argv)\n\n    # Run Controller for each file\n    for file in files_to_process:\n        run_controller(\n            data_file=file, \n            particles_to_simulate=args.filep, \n            alphap=args.alphap, \n            ref_ion=args.refion, \n            harmonics=args.harmonics, \n            brho=args.brho, \n            fref=args.fref, \n            ke=args.kenergy, \n            gam=args.gamma, \n            correct=args.correct, \n            ods=args.ods, \n            nions=args.nions,\n            show=args.show,\n            app=app\n        )\n\n    if args.show and app:\n        sys.exit(app.exec_())\n</code></pre>"},{"location":"reference/rionid/__main__/#rionid.__main__.read_masterfile","title":"<code>read_masterfile(master_filename)</code>","text":"<p>Reads list of filenames from a text file.</p> Source code in <code>src/rionid/__main__.py</code> <pre><code>def read_masterfile(master_filename):\n    \"\"\"Reads list of filenames from a text file.\"\"\"\n    return [file.strip() for file in open(master_filename).readlines() if file.strip()]\n</code></pre>"},{"location":"reference/rionid/__main__/#rionid.__main__.run_controller","title":"<code>run_controller(data_file, particles_to_simulate, alphap, ref_ion, harmonics, brho=None, fref=None, ke=None, gam=None, correct=None, ods=False, nions=None, show=True, app=None)</code>","text":"<p>Unified controller: Calculates physics and launches the PyQt GUI.</p> <p>Parameters:</p> Name Type Description Default <code>data_file</code> <code>str</code> <p>Path to experimental data.</p> required <code>particles_to_simulate</code> <code>str</code> <p>Path to LISE++ file.</p> required <code>alphap</code> <code>float</code> <p>Momentum compaction factor.</p> required <code>ref_ion</code> <code>str</code> <p>Reference ion string.</p> required <code>harmonics</code> <code>list</code> <p>List of harmonics to simulate.</p> required <code>brho</code> <code>float</code> <p>Magnetic rigidity.</p> <code>None</code> <code>fref</code> <code>float</code> <p>Reference frequency.</p> <code>None</code> <code>ke</code> <code>float</code> <p>Kinetic energy.</p> <code>None</code> <code>gam</code> <code>float</code> <p>Gamma factor.</p> <code>None</code> <code>correct</code> <code>list</code> <p>Polynomial correction coefficients.</p> <code>None</code> <code>ods</code> <code>bool</code> <p>Whether to export to ODS.</p> <code>False</code> <code>nions</code> <code>int</code> <p>Number of top ions to display.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to show the GUI.</p> <code>True</code> <code>app</code> <code>QApplication</code> <p>The Qt application instance.</p> <code>None</code> Source code in <code>src/rionid/__main__.py</code> <pre><code>def run_controller(data_file, particles_to_simulate, alphap, ref_ion, harmonics, \n                   brho=None, fref=None, ke=None, gam=None, correct=None, \n                   ods=False, nions=None, show=True, app=None):\n    \"\"\"\n    Unified controller: Calculates physics and launches the PyQt GUI.\n\n    Parameters\n    ----------\n    data_file : str\n        Path to experimental data.\n    particles_to_simulate : str\n        Path to LISE++ file.\n    alphap : float\n        Momentum compaction factor.\n    ref_ion : str\n        Reference ion string.\n    harmonics : list\n        List of harmonics to simulate.\n    brho : float, optional\n        Magnetic rigidity.\n    fref : float, optional\n        Reference frequency.\n    ke : float, optional\n        Kinetic energy.\n    gam : float, optional\n        Gamma factor.\n    correct : list, optional\n        Polynomial correction coefficients.\n    ods : bool, optional\n        Whether to export to ODS.\n    nions : int, optional\n        Number of top ions to display.\n    show : bool, optional\n        Whether to show the GUI.\n    app : QApplication, optional\n        The Qt application instance.\n    \"\"\"\n    # 1. Calculations (Model)\n    mydata = ImportData(ref_ion, alphap, filename=data_file)\n    log.debug(f'Experimental data shape: {shape(mydata.experimental_data)}')\n\n    mydata._set_particles_to_simulate_from_file(particles_to_simulate)\n    mydata._calculate_moqs()\n\n    # Calculate Reference Frequency\n    mydata._calculate_srrf(fref=fref, brho=brho, ke=ke, gam=gam, correct=correct)\n    log.debug(f'Reference Frequency: {mydata.ref_frequency}')\n\n    # Simulate Data\n    if not isinstance(harmonics, list):\n        harmonics = [harmonics]\n\n    mydata._simulated_data(harmonics=harmonics, brho=brho, mode='Frequency' if fref else 'Brho') \n\n    # 2. Filter Ions (Optional)\n    if nions: \n        display_nions(nions, mydata.yield_data, mydata.nuclei_names, mydata.simulated_data_dict, ref_ion, harmonics)\n\n    # 3. Logging &amp; ODS Export\n    sort_index = argsort(mydata.srrf)\n    if ods: \n        write_arrays_to_ods(\n            'Data_simulated_RionID', \n            'Data', \n            ['Name', 'freq', 'yield'], \n            (mydata.nuclei_names)[sort_index], \n            (mydata.srrf)[sort_index] * mydata.ref_frequency, \n            (mydata.yield_data)[sort_index] \n        )\n\n    # 4. Visualization (View)\n    if show and app:\n        sa = CreatePyGUI(mydata.experimental_data, mydata.simulated_data_dict)\n        sa.show()\n</code></pre>"},{"location":"reference/rionid/baseline/","title":"Baseline","text":""},{"location":"reference/rionid/baseline/#rionid.baseline","title":"<code>rionid.baseline</code>","text":""},{"location":"reference/rionid/baseline/#rionid.baseline.NONPARAMS_EST","title":"<code>NONPARAMS_EST</code>","text":"<p>               Bases: <code>object</code></p> <p>Wrapper class for non-parametric baseline estimation algorithms.</p> <p>This class provides a unified interface to access various baseline subtraction methods, primarily Penalized Least Squares (PLS) variants.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>The input 1D spectrum array (e.g., Power Spectral Density) from which the baseline should be estimated.</p> required Source code in <code>src/rionid/baseline.py</code> <pre><code>class NONPARAMS_EST(object):\n    \"\"\"\n    Wrapper class for non-parametric baseline estimation algorithms.\n\n    This class provides a unified interface to access various baseline subtraction\n    methods, primarily Penalized Least Squares (PLS) variants.\n\n    Parameters\n    ----------\n    data : array-like\n        The input 1D spectrum array (e.g., Power Spectral Density) from which\n        the baseline should be estimated.\n    \"\"\"\n    def __init__(self, data):\n        self.data = data\n\n    def pls(self, method, l, **kwargs):\n        \"\"\"\n        Executes a Penalized Least Squares (PLS) baseline estimation.\n\n        Parameters\n        ----------\n        method : str\n            The specific PLS algorithm to use. Currently supports 'BrPLS'.\n        l : float\n            The smoothness parameter (lambda). Higher values result in a stiffer,\n            smoother baseline. Typical values range from 10^5 to 10^8 for Schottky spectra.\n        **kwargs : dict\n            Additional arguments passed to the specific PLS method (e.g., 'ratio', 'nitermax').\n\n        Returns\n        -------\n        numpy.ndarray\n            The estimated baseline array, with the same shape as the input data.\n\n        Raises\n        ------\n        ValueError\n            If the specified `method` is not implemented.\n        \"\"\"\n        pls_method = PLS(self.data)\n        if method == 'BrPLS':\n            return pls_method.BrPLS(l=l, **kwargs)\n        else:\n            raise ValueError(f\"Method {method} not implemented.\")\n</code></pre>"},{"location":"reference/rionid/baseline/#rionid.baseline.NONPARAMS_EST.pls","title":"<code>pls(method, l, **kwargs)</code>","text":"<p>Executes a Penalized Least Squares (PLS) baseline estimation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The specific PLS algorithm to use. Currently supports 'BrPLS'.</p> required <code>l</code> <code>float</code> <p>The smoothness parameter (lambda). Higher values result in a stiffer, smoother baseline. Typical values range from 10^5 to 10^8 for Schottky spectra.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to the specific PLS method (e.g., 'ratio', 'nitermax').</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The estimated baseline array, with the same shape as the input data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified <code>method</code> is not implemented.</p> Source code in <code>src/rionid/baseline.py</code> <pre><code>def pls(self, method, l, **kwargs):\n    \"\"\"\n    Executes a Penalized Least Squares (PLS) baseline estimation.\n\n    Parameters\n    ----------\n    method : str\n        The specific PLS algorithm to use. Currently supports 'BrPLS'.\n    l : float\n        The smoothness parameter (lambda). Higher values result in a stiffer,\n        smoother baseline. Typical values range from 10^5 to 10^8 for Schottky spectra.\n    **kwargs : dict\n        Additional arguments passed to the specific PLS method (e.g., 'ratio', 'nitermax').\n\n    Returns\n    -------\n    numpy.ndarray\n        The estimated baseline array, with the same shape as the input data.\n\n    Raises\n    ------\n    ValueError\n        If the specified `method` is not implemented.\n    \"\"\"\n    pls_method = PLS(self.data)\n    if method == 'BrPLS':\n        return pls_method.BrPLS(l=l, **kwargs)\n    else:\n        raise ValueError(f\"Method {method} not implemented.\")\n</code></pre>"},{"location":"reference/rionid/baseline/#rionid.baseline.PLS","title":"<code>PLS</code>","text":"<p>               Bases: <code>object</code></p> <p>Implementation of Penalized Least Squares (PLS) algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>The input 1D spectrum array.</p> required Source code in <code>src/rionid/baseline.py</code> <pre><code>class PLS(object):\n    \"\"\"\n    Implementation of Penalized Least Squares (PLS) algorithms.\n\n    Parameters\n    ----------\n    data : array-like\n        The input 1D spectrum array.\n    \"\"\"\n    def __init__(self, data):\n        self.data = data\n\n    def BrPLS(self, l, ratio=1e-6, nitermax=50):\n        \"\"\"\n        Bayesian reweighted Penalized Least Squares (BrPLS).\n\n        This algorithm estimates the baseline by iteratively reweighting the data points.\n        It assumes that the baseline is smooth and that peaks are positive deviations\n        from this baseline. It uses a Bayesian approach to update weights based on\n        the probability that a point belongs to the background noise versus a peak.\n\n        Reference: Q. Wang et al., NUCL SCI TECH, 33: 148 (2022).\n\n        Parameters\n        ----------\n        l : float\n            Smoothness parameter (lambda). Controls the trade-off between fidelity to\n            the data and smoothness of the baseline.\n        ratio : float, optional\n            Convergence threshold. The iteration stops when the relative change in\n            the baseline vector is less than this value. Default is 1e-6.\n        nitermax : int, optional\n            Maximum number of iterations. Default is 50.\n\n        Returns\n        -------\n        numpy.ndarray\n            The calculated baseline array.\n        \"\"\"\n        L, beta = len(self.data), 0.5\n\n        # Construct the difference matrix (2nd order derivative approximation)\n        D = sparse.diags([1,-2,1], [0,-1,-2], shape=(L, L-2))\n        D = l * D.dot(D.transpose())\n\n        w, z = np.ones(L), self.data.copy()\n\n        for i in range(nitermax):\n            # Solve the linear system (W + D)z = Wy\n            W = sparse.spdiags(w, 0, L, L)\n            Z = W + D\n            zt = spsolve(Z, w*self.data)\n\n            # Calculate residuals\n            d = self.data - zt\n\n            # Separate positive and negative residuals to estimate noise statistics\n            d_pos = d[d &gt; 0]\n            d_neg = d[d &lt; 0]\n\n            # Robust mean and sigma estimation (avoid division by zero)\n            d_m = np.mean(d_pos) if len(d_pos) &gt; 0 else 1e-6\n            d_sigma = np.sqrt(np.mean(d_neg**2)) if len(d_neg) &gt; 0 else 1e-6\n\n            # Bayesian weight update formula using Error Function (erf)\n            # This calculates the probability that a point is part of the baseline\n            w = 1 / (1 + beta / (1 - beta) * np.sqrt(np.pi / 2) * d_sigma / d_m * \n                     (1 + sp.erf((d / d_sigma - d_sigma / d_m) / np.sqrt(2))) * \n                     np.exp((d / d_sigma - d_sigma / d_m)**2 / 2))\n\n            # Check convergence of the baseline vector z\n            if np.sqrt(np.sum((z - zt)**2) / np.sum(z**2)) &lt; ratio: break\n            z = zt\n\n            # Update prior probability beta\n            if np.abs(beta + np.mean(w) - 1.) &lt; ratio: break\n            beta = 1 - np.mean(w)\n\n        return z\n</code></pre>"},{"location":"reference/rionid/baseline/#rionid.baseline.PLS.BrPLS","title":"<code>BrPLS(l, ratio=1e-06, nitermax=50)</code>","text":"<p>Bayesian reweighted Penalized Least Squares (BrPLS).</p> <p>This algorithm estimates the baseline by iteratively reweighting the data points. It assumes that the baseline is smooth and that peaks are positive deviations from this baseline. It uses a Bayesian approach to update weights based on the probability that a point belongs to the background noise versus a peak.</p> <p>Reference: Q. Wang et al., NUCL SCI TECH, 33: 148 (2022).</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Smoothness parameter (lambda). Controls the trade-off between fidelity to the data and smoothness of the baseline.</p> required <code>ratio</code> <code>float</code> <p>Convergence threshold. The iteration stops when the relative change in the baseline vector is less than this value. Default is 1e-6.</p> <code>1e-06</code> <code>nitermax</code> <code>int</code> <p>Maximum number of iterations. Default is 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The calculated baseline array.</p> Source code in <code>src/rionid/baseline.py</code> <pre><code>def BrPLS(self, l, ratio=1e-6, nitermax=50):\n    \"\"\"\n    Bayesian reweighted Penalized Least Squares (BrPLS).\n\n    This algorithm estimates the baseline by iteratively reweighting the data points.\n    It assumes that the baseline is smooth and that peaks are positive deviations\n    from this baseline. It uses a Bayesian approach to update weights based on\n    the probability that a point belongs to the background noise versus a peak.\n\n    Reference: Q. Wang et al., NUCL SCI TECH, 33: 148 (2022).\n\n    Parameters\n    ----------\n    l : float\n        Smoothness parameter (lambda). Controls the trade-off between fidelity to\n        the data and smoothness of the baseline.\n    ratio : float, optional\n        Convergence threshold. The iteration stops when the relative change in\n        the baseline vector is less than this value. Default is 1e-6.\n    nitermax : int, optional\n        Maximum number of iterations. Default is 50.\n\n    Returns\n    -------\n    numpy.ndarray\n        The calculated baseline array.\n    \"\"\"\n    L, beta = len(self.data), 0.5\n\n    # Construct the difference matrix (2nd order derivative approximation)\n    D = sparse.diags([1,-2,1], [0,-1,-2], shape=(L, L-2))\n    D = l * D.dot(D.transpose())\n\n    w, z = np.ones(L), self.data.copy()\n\n    for i in range(nitermax):\n        # Solve the linear system (W + D)z = Wy\n        W = sparse.spdiags(w, 0, L, L)\n        Z = W + D\n        zt = spsolve(Z, w*self.data)\n\n        # Calculate residuals\n        d = self.data - zt\n\n        # Separate positive and negative residuals to estimate noise statistics\n        d_pos = d[d &gt; 0]\n        d_neg = d[d &lt; 0]\n\n        # Robust mean and sigma estimation (avoid division by zero)\n        d_m = np.mean(d_pos) if len(d_pos) &gt; 0 else 1e-6\n        d_sigma = np.sqrt(np.mean(d_neg**2)) if len(d_neg) &gt; 0 else 1e-6\n\n        # Bayesian weight update formula using Error Function (erf)\n        # This calculates the probability that a point is part of the baseline\n        w = 1 / (1 + beta / (1 - beta) * np.sqrt(np.pi / 2) * d_sigma / d_m * \n                 (1 + sp.erf((d / d_sigma - d_sigma / d_m) / np.sqrt(2))) * \n                 np.exp((d / d_sigma - d_sigma / d_m)**2 / 2))\n\n        # Check convergence of the baseline vector z\n        if np.sqrt(np.sum((z - zt)**2) / np.sum(z**2)) &lt; ratio: break\n        z = zt\n\n        # Update prior probability beta\n        if np.abs(beta + np.mean(w) - 1.) &lt; ratio: break\n        beta = 1 - np.mean(w)\n\n    return z\n</code></pre>"},{"location":"reference/rionid/core/","title":"Core","text":""},{"location":"reference/rionid/core/#rionid.core","title":"<code>rionid.core</code>","text":""},{"location":"reference/rionid/core/#rionid.core.ImportData","title":"<code>ImportData</code>","text":"<p>               Bases: <code>object</code></p> <p>The core data model for RionID.</p> <p>This class handles the loading of experimental data, the physics calculations for ion revolution frequencies, and the simulation of expected spectra based on input parameters (LISE++ files, ring settings).</p> <p>Parameters:</p> Name Type Description Default <code>refion</code> <code>str</code> <p>Reference ion string (e.g., '72Ge+35').</p> required <code>alphap</code> <code>float</code> <p>Momentum compaction factor of the ring.</p> required <code>filename</code> <code>str</code> <p>Path to the experimental data file.</p> <code>None</code> <code>reload_data</code> <code>bool</code> <p>If True, reloads raw data; otherwise loads from cache.</p> <code>None</code> <code>circumference</code> <code>float</code> <p>Ring circumference in meters.</p> <code>None</code> <code>highlight_ions</code> <code>str or list</code> <p>Ions to highlight in the plot.</p> <code>None</code> <code>remove_baseline</code> <code>bool</code> <p>Whether to apply baseline subtraction.</p> <code>False</code> <code>psd_baseline_removed_l</code> <code>float</code> <p>Smoothness parameter for baseline removal.</p> <code>1000000.0</code> <code>peak_threshold_pct</code> <code>float</code> <p>Peak detection threshold (0.0-1.0).</p> <code>0.05</code> <code>min_distance</code> <code>float</code> <p>Minimum distance between peaks.</p> <code>10</code> <code>matching_freq_min</code> <code>float</code> <p>Minimum frequency for peak matching.</p> <code>None</code> <code>matching_freq_max</code> <code>float</code> <p>Maximum frequency for peak matching.</p> <code>None</code> <code>io_params</code> <code>dict</code> <p>Extra parameters for file I/O (e.g., NPZ keys).</p> <code>None</code> Source code in <code>src/rionid/core.py</code> <pre><code>class ImportData(object):\n    \"\"\"\n    The core data model for RionID.\n\n    This class handles the loading of experimental data, the physics calculations\n    for ion revolution frequencies, and the simulation of expected spectra based\n    on input parameters (LISE++ files, ring settings).\n\n    Parameters\n    ----------\n    refion : str\n        Reference ion string (e.g., '72Ge+35').\n    alphap : float\n        Momentum compaction factor of the ring.\n    filename : str, optional\n        Path to the experimental data file.\n    reload_data : bool, optional\n        If True, reloads raw data; otherwise loads from cache.\n    circumference : float, optional\n        Ring circumference in meters.\n    highlight_ions : str or list, optional\n        Ions to highlight in the plot.\n    remove_baseline : bool, optional\n        Whether to apply baseline subtraction.\n    psd_baseline_removed_l : float, optional\n        Smoothness parameter for baseline removal.\n    peak_threshold_pct : float, optional\n        Peak detection threshold (0.0-1.0).\n    min_distance : float, optional\n        Minimum distance between peaks.\n    matching_freq_min : float, optional\n        Minimum frequency for peak matching.\n    matching_freq_max : float, optional\n        Maximum frequency for peak matching.\n    io_params : dict, optional\n        Extra parameters for file I/O (e.g., NPZ keys).\n    \"\"\"\n\n    def __init__(self, refion, alphap, filename=None, reload_data=None, circumference=None,\n                 highlight_ions=None, remove_baseline=False, psd_baseline_removed_l=1e6,\n                 peak_threshold_pct=0.05, min_distance=10, matching_freq_min=None, \n                 matching_freq_max=None, io_params=None):\n\n        self.simulated_data_dict = {}\n        self.particles_to_simulate = []\n        self.moq = dict()\n        self.protons = dict()\n        self.total_mass = dict()\n        self.yield_data = []\n\n        self.highlight_ions = self._parse_highlight_ions(highlight_ions)\n        self.alphap = alphap\n        self.gammat = 1.0 / (self.alphap ** 0.5)\n\n        self.ring = Ring('ESR', circumference)\n\n        self.ref_ion = refion.strip()\n        self._parse_ref_ion(refion)\n\n        # Physics / Matching Params\n        self.peak_threshold_pct = float(peak_threshold_pct) if peak_threshold_pct else 0.05\n        self.min_distance = float(min_distance) if min_distance else 10\n        self.matching_freq_min = matching_freq_min\n        self.matching_freq_max = matching_freq_max\n        self.remove_baseline = remove_baseline\n        self.psd_baseline_removed_l = psd_baseline_removed_l\n        self.io_params = io_params or {} \n\n        # Results containers\n        self.peak_freqs = []\n        self.peak_heights = []\n        self.chi2 = 0\n        self.match_count = 0\n\n        self.cache_file = self._get_cache_file_path(filename) if filename else None\n        self.experimental_data = None\n\n        if filename is not None:\n            if reload_data:\n                self._get_experimental_data(filename)\n                self._save_experimental_data()\n            else:\n                try:\n                    self._load_experimental_data()\n                except (FileNotFoundError, IOError):\n                    self._get_experimental_data(filename)\n\n            # --- NEW DATA PROCESSING BLOCK ---\n            if self.experimental_data is not None:\n                freq, amp = self.experimental_data\n\n                # 1. Baseline Removal\n                if remove_baseline:\n                    try:\n                        est = NONPARAMS_EST(amp)\n                        baseline = est.pls('BrPLS', l=psd_baseline_removed_l, ratio=1e-6)\n                        amp = amp - baseline\n                    except Exception as e:\n                        print(f\"Baseline removal failed: {e}\")\n                        traceback.print_exc()\n\n                # 2. Log-Safety (Clip negatives)\n                # Ensure all values are &gt; 0 for logarithmic plotting. \n                # We use 1e-9 as a \"floor\" value.\n                amp = np.maximum(amp, 1e-29)\n\n                # 3. Normalization\n                # Scale so the highest peak is 1.0\n                max_val = np.max(amp)\n                if max_val &gt; 0:\n                    amp = amp / max_val\n\n                # Update the stored data\n                self.experimental_data = (freq, amp)\n            # ---------------------------------\n\n            # Process peaks after loading and processing\n            self.detect_peaks_and_widths()\n\n    def _parse_ref_ion(self, refion):\n        # Regex to extract Mass(Digits), Element(Letters), Charge(Digits)\n        # It handles both '98Zr+39' and '98Zr39+' inputs\n        match = re.match(r'(\\d+)([a-zA-Z]+).*?(\\d+)', self.ref_ion)\n        if match:\n            self.ref_aa = int(match.group(1))\n            self.ref_el = match.group(2)\n            self.ref_charge = int(match.group(3))\n            # Force standard format: 98Zr39+\n            self.ref_ion = f\"{self.ref_aa}{self.ref_el}{self.ref_charge}+\"\n        else:\n            # Fallback parsing\n            try:\n                # Try splitting by '+' if it exists in the middle\n                if '+' in refion and not refion.endswith('+'):\n                    parts = refion.split('+')\n                    self.ref_charge = int(parts[1])\n                    self.ref_aa = int(re.split(r'(\\d+)', parts[0])[1])\n                else:\n                    # Assume format like 98Zr39+\n                    self.ref_charge = int(re.findall(r'\\d+', refion)[-1])\n                    self.ref_aa = int(re.findall(r'\\d+', refion)[0])\n            except:\n                print(f\"Warning: Could not parse reference ion '{refion}'.\")\n\n    def _parse_highlight_ions(self, input_str):\n        \"\"\"Parses a comma-separated string of ions into a list.\"\"\"\n        if not input_str: return []\n        if isinstance(input_str, list): return input_str\n        return [x.strip() for x in input_str.split(',') if x.strip()]\n\n    def _get_cache_file_path(self, filename):\n        \"\"\"Generates the cache filename.\"\"\"\n        base, _ = os.path.splitext(filename)\n        return f\"{base}_cache.npz\"\n\n    def _get_experimental_data(self, filename):\n        \"\"\"Loads experimental data from various file formats.\"\"\"\n        base, file_extension = os.path.splitext(filename)\n        ext = file_extension.lower()\n\n        if ext == '.csv':\n            self.experimental_data = read_psdata(filename, dbm=False)\n        elif ext in ['.bin_fre', '.bin_time', '.bin_amp']:\n            self.experimental_data = handle_read_tdsm_bin(filename)\n        elif ext == '.npz':\n            self.experimental_data = handle_spectrumnpz_data(filename, **self.io_params)\n            #if 'spectrum' in base:\n            #    self.experimental_data = handle_spectrumnpz_data(filename, **self.io_params)\n            #else:\n            #    self.experimental_data = handle_tiqnpz_data(filename, **self.io_params)\n        elif ext == '.root':\n            raise ValueError(\"ROOT files are not supported in this version. Please convert to NPZ/CSV.\")\n\n        # Baseline removal\n        if self.remove_baseline and self.experimental_data:\n            try:\n                freq, psd = self.experimental_data\n                est = NONPARAMS_EST(psd)\n                baseline = est.pls('BrPLS', l=self.psd_baseline_removed_l, ratio=1e-6)\n                self.experimental_data = (freq, psd - baseline)\n            except Exception as e:\n                traceback.print_exc()\n\n    def detect_peaks_and_widths(self):\n        \"\"\"\n        Detects peaks in the experimental spectrum using scipy.signal.find_peaks.\n\n        Updates `self.peak_freqs` and `self.peak_heights`.\n        \"\"\"\n        if self.experimental_data is None: return\n        freq, amp = self.experimental_data\n\n        rel_height = max(0.0, min(self.peak_threshold_pct, 1.0))\n        height_thresh = np.max(amp) * rel_height\n\n        peaks, _ = find_peaks(\n            amp,\n            height=height_thresh,\n            distance=self.min_distance,\n            prominence=height_thresh * 0.2,\n            width=1\n        )\n\n        # Filter by frequency window\n        peak_freqs = freq[peaks]\n        mask = np.ones_like(peaks, dtype=bool)\n        if self.matching_freq_min is not None:\n            mask &amp;= (peak_freqs &gt;= self.matching_freq_min)\n        if self.matching_freq_max is not None:\n            mask &amp;= (peak_freqs &lt;= self.matching_freq_max)\n\n        self.peak_freqs = peak_freqs[mask]\n        self.peak_heights = amp[peaks][mask]\n        self.peak_widths_freq = np.zeros_like(self.peak_freqs) \n\n    def compute_matches(self, match_threshold, f_min=None, f_max=None):\n        \"\"\"\n        Matches simulated ions to experimental peaks.\n\n        Parameters\n        ----------\n        match_threshold : float\n            Max frequency difference (Hz) to consider a match.\n        f_min : float, optional\n            Min frequency bound for matching.\n        f_max : float, optional\n            Max frequency bound for matching.\n\n        Returns\n        -------\n        tuple\n            (chi2, match_count, highlight_ions)\n        \"\"\"\n        sim_items = []\n        for h_name, sdata in self.simulated_data_dict.items():\n            harmonic = float(h_name)\n            for row in sdata:\n                sim_items.append((float(row[0]), row[2], harmonic))\n\n        if not sim_items: return 0, 0, []\n\n        sim_freqs = np.array([x[0] for x in sim_items])\n        chi2 = 0.0\n        match_count = 0\n        matched_ions = []\n\n        # Logic: For every experimental peak, find closest simulated line\n        for exp_freq in self.peak_freqs:\n            if f_min and exp_freq &lt; f_min: continue\n            if f_max and exp_freq &gt; f_max: continue\n\n            idx = np.argmin(np.abs(sim_freqs - exp_freq))\n            diff = abs(sim_freqs[idx] - exp_freq)\n\n            if diff &lt;= match_threshold:\n                chi2 += diff**2\n                match_count += 1\n                matched_ions.append(sim_items[idx][1])\n\n        self.chi2 = chi2 / match_count if match_count &gt; 0 else float('inf')\n        self.match_count = match_count\n        self.highlight_ions = list(set(matched_ions)) # Update highlights with matches\n\n        return self.chi2, self.match_count, self.highlight_ions\n\n    def save_matched_result(self, filename):\n        \"\"\"Saves the list of matched ions to a text file.\"\"\"\n        if not filename or not self.highlight_ions: return\n        with open(filename, 'w') as f:\n            f.write(\"Matched Ions List\\n\")\n            for ion in self.highlight_ions:\n                f.write(f\"{ion}\\n\")\n        print(f\"Matched results saved to {filename}\")\n\n    def _save_experimental_data(self):\n        \"\"\"Caches loaded data to a compressed NPZ file.\"\"\"\n        if self.experimental_data is not None:\n            frequency, amplitude_avg = self.experimental_data\n            np.savez_compressed(self.cache_file, frequency=frequency, amplitude_avg=amplitude_avg)                        \n\n    def _load_experimental_data(self):\n        \"\"\"Loads data from the cache file.\"\"\"\n        if os.path.exists(self.cache_file):\n            data = np.load(self.cache_file, allow_pickle=True)\n            frequency = data['frequency']\n            amplitude_avg = data['amplitude_avg']\n            self.experimental_data = (frequency, amplitude_avg)\n        else:\n            raise FileNotFoundError(\"Cached data file not found. Please set reload_data to True to generate it.\")\n\n    def _set_particles_to_simulate_from_file(self, particles_to_simulate):\n        \"\"\"Parses the LISE++ output file.\"\"\"\n        self.ame = AMEData()\n        self.ame_data = self.ame.ame_table\n        lise = LISEreader(particles_to_simulate)\n        self.particles_to_simulate = lise.get_info_all()\n\n    def _calculate_moqs(self, particles = None):\n        \"\"\"Calculates mass-to-charge ratios for all particles.\"\"\"\n        self.moq = dict()\n        self.total_mass = dict()\n\n        if particles:\n            for particle in particles:\n                ion_name = f'{particle.tbl_aa}{particle.tbl_name}{particle.qq}+'\n                m_q = particle.get_ionic_moq_in_u()\n                self.moq[ion_name] = m_q\n                self.total_mass[ion_name] = m_q * particle.qq\n        else:\n            for particle in self.particles_to_simulate:\n                ion_name = f'{particle[1]}{particle[0]}{particle[4][-1]}+'\n                for ame in self.ame_data:\n                    if particle[0] == ame[6] and particle[1] == ame[5]:\n                        pp = Particle(particle[2], particle[3], self.ame, self.ring)\n                        pp.qq = particle[4][-1]\n                        m_q = pp.get_ionic_moq_in_u()\n                        self.moq[ion_name] = m_q\n                        self.total_mass[ion_name] = m_q * pp.qq\n                        self.protons[ion_name] = ame[4]\n                        break\n\n    def _calculate_srrf(self, fref=None, brho=None, ke=None, gam=None, correct=None):\n        \"\"\"\n        Calculates Simulated Relative Revolution Frequencies (SRRF).\n\n        Applies the slip factor formula and optional polynomial correction.\n        \"\"\"\n        self.ref_mass = AMEData.to_mev(self.moq[self.ref_ion] * self.ref_charge)\n        self.ref_frequency = self.reference_frequency(fref, brho, ke, gam)\n        self.srrf = array([1 - self.alphap * (self.moq[name] - self.moq[self.ref_ion]) / self.moq[self.ref_ion]\n                           for name in self.moq])\n        if correct:\n            correction = polyval(array(correct), self.srrf * self.ref_frequency)\n            self.srrf = self.srrf + correction / self.ref_frequency\n\n    def _simulated_data(self, brho=None, harmonics=None, mode=None, sim_scalingfactor=None, nions=None):\n        \"\"\"Generates the final simulation dictionary for plotting.\"\"\"\n        for harmonic in harmonics:\n            ref_moq = self.moq[self.ref_ion]\n            if mode == 'brho':\n                self.brho = brho\n                ref_frequency = self.ref_frequency * harmonic\n            else:\n                ref_frequency = self.ref_frequency\n                self.brho = self.calculate_brho_relativistic(ref_moq, ref_frequency, self.ring.circumference, harmonic)\n\n        self.simulated_data_dict = {}\n        self.yield_data = []\n        moq_keys = list(self.moq.keys())\n\n        for key in moq_keys:\n            found = False\n            for p in self.particles_to_simulate:\n                p_name = f\"{int(p[1])}{p[0]}{int(p[4][-1])}+\"\n                if p_name == key:\n                    self.yield_data.append(p[5])\n                    found = True\n                    break\n            if not found: self.yield_data.append(0)\n\n        self.nuclei_names = array(moq_keys)\n        self.yield_data = np.array(self.yield_data, dtype=float)\n        max_yield = np.max(self.yield_data)\n        if max_yield &gt; 0:\n            self.yield_data /= max_yield\n\n        if sim_scalingfactor:\n            self.yield_data *= sim_scalingfactor\n\n        for harmonic in harmonics:\n            harmonic_freq = self.srrf * self.ref_frequency * harmonic\n            arr_stack = stack((harmonic_freq, self.yield_data, self.nuclei_names), axis=1)\n            self.simulated_data_dict[f'{harmonic}'] = arr_stack\n\n    def calculate_brho_relativistic(self, moq, frequency, circumference, harmonic):\n        \"\"\"Calculates Magnetic Rigidity (Brho) from frequency.\"\"\"\n        actual_frequency = frequency / harmonic\n        v = actual_frequency * circumference\n        gamma = 1 / np.sqrt(1 - (v / AMEData.CC) ** 2)\n        p = moq * AMEData.UU * gamma * (v / AMEData.CC) \n        brho = (p / AMEData.CC) * 1e6 \n        return brho\n\n    def reference_frequency(self, fref=None, brho=None, ke=None, gam=None):\n        \"\"\"Determines the reference frequency based on input mode.\"\"\"\n        if fref: return fref\n        elif brho: return ImportData.calc_ref_rev_frequency(self.ref_mass, self.ring.circumference, brho=brho, ref_charge=self.ref_charge)\n        elif ke: return ImportData.calc_ref_rev_frequency(self.ref_mass, self.ring.circumference, ke=ke, aa=self.ref_aa)\n        elif gam: return ImportData.calc_ref_rev_frequency(self.ref_mass, self.ring.circumference, gam=gam)\n        else: sys.exit('Error: No reference parameter provided.')\n\n    @staticmethod\n    def calc_ref_rev_frequency(ref_mass, ring_circumference, brho=None, ref_charge=None, ke=None, aa=None, gam=None):\n        \"\"\"Static helper to calculate revolution frequency.\"\"\"\n        if brho: gamma = ImportData.gamma_brho(brho, ref_charge, ref_mass)\n        elif ke: gamma = ImportData.gamma_ke(ke, aa, ref_mass)\n        elif gam: gamma = gam\n        beta = ImportData.beta(gamma)\n        return ImportData.velocity(beta) / ring_circumference\n\n    @staticmethod\n    def gamma_brho(brho, charge, mass): return sqrt(pow(brho * charge * AMEData.CC / (mass * 1e6), 2)+1)\n    @staticmethod\n    def gamma_ke(ke, aa, ref_mass): return (ke * aa) / (ref_mass) + 1\n    @staticmethod\n    def beta(gamma): return sqrt(gamma**2 - 1) / gamma\n    @staticmethod\n    def velocity(beta): return AMEData.CC * beta\n    @staticmethod\n    def calc_revolution_frequency(velocity, ring_circumference): return velocity / ring_circumference\n</code></pre>"},{"location":"reference/rionid/core/#rionid.core.ImportData.calc_ref_rev_frequency","title":"<code>calc_ref_rev_frequency(ref_mass, ring_circumference, brho=None, ref_charge=None, ke=None, aa=None, gam=None)</code>  <code>staticmethod</code>","text":"<p>Static helper to calculate revolution frequency.</p> Source code in <code>src/rionid/core.py</code> <pre><code>@staticmethod\ndef calc_ref_rev_frequency(ref_mass, ring_circumference, brho=None, ref_charge=None, ke=None, aa=None, gam=None):\n    \"\"\"Static helper to calculate revolution frequency.\"\"\"\n    if brho: gamma = ImportData.gamma_brho(brho, ref_charge, ref_mass)\n    elif ke: gamma = ImportData.gamma_ke(ke, aa, ref_mass)\n    elif gam: gamma = gam\n    beta = ImportData.beta(gamma)\n    return ImportData.velocity(beta) / ring_circumference\n</code></pre>"},{"location":"reference/rionid/core/#rionid.core.ImportData.calculate_brho_relativistic","title":"<code>calculate_brho_relativistic(moq, frequency, circumference, harmonic)</code>","text":"<p>Calculates Magnetic Rigidity (Brho) from frequency.</p> Source code in <code>src/rionid/core.py</code> <pre><code>def calculate_brho_relativistic(self, moq, frequency, circumference, harmonic):\n    \"\"\"Calculates Magnetic Rigidity (Brho) from frequency.\"\"\"\n    actual_frequency = frequency / harmonic\n    v = actual_frequency * circumference\n    gamma = 1 / np.sqrt(1 - (v / AMEData.CC) ** 2)\n    p = moq * AMEData.UU * gamma * (v / AMEData.CC) \n    brho = (p / AMEData.CC) * 1e6 \n    return brho\n</code></pre>"},{"location":"reference/rionid/core/#rionid.core.ImportData.compute_matches","title":"<code>compute_matches(match_threshold, f_min=None, f_max=None)</code>","text":"<p>Matches simulated ions to experimental peaks.</p> <p>Parameters:</p> Name Type Description Default <code>match_threshold</code> <code>float</code> <p>Max frequency difference (Hz) to consider a match.</p> required <code>f_min</code> <code>float</code> <p>Min frequency bound for matching.</p> <code>None</code> <code>f_max</code> <code>float</code> <p>Max frequency bound for matching.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(chi2, match_count, highlight_ions)</p> Source code in <code>src/rionid/core.py</code> <pre><code>def compute_matches(self, match_threshold, f_min=None, f_max=None):\n    \"\"\"\n    Matches simulated ions to experimental peaks.\n\n    Parameters\n    ----------\n    match_threshold : float\n        Max frequency difference (Hz) to consider a match.\n    f_min : float, optional\n        Min frequency bound for matching.\n    f_max : float, optional\n        Max frequency bound for matching.\n\n    Returns\n    -------\n    tuple\n        (chi2, match_count, highlight_ions)\n    \"\"\"\n    sim_items = []\n    for h_name, sdata in self.simulated_data_dict.items():\n        harmonic = float(h_name)\n        for row in sdata:\n            sim_items.append((float(row[0]), row[2], harmonic))\n\n    if not sim_items: return 0, 0, []\n\n    sim_freqs = np.array([x[0] for x in sim_items])\n    chi2 = 0.0\n    match_count = 0\n    matched_ions = []\n\n    # Logic: For every experimental peak, find closest simulated line\n    for exp_freq in self.peak_freqs:\n        if f_min and exp_freq &lt; f_min: continue\n        if f_max and exp_freq &gt; f_max: continue\n\n        idx = np.argmin(np.abs(sim_freqs - exp_freq))\n        diff = abs(sim_freqs[idx] - exp_freq)\n\n        if diff &lt;= match_threshold:\n            chi2 += diff**2\n            match_count += 1\n            matched_ions.append(sim_items[idx][1])\n\n    self.chi2 = chi2 / match_count if match_count &gt; 0 else float('inf')\n    self.match_count = match_count\n    self.highlight_ions = list(set(matched_ions)) # Update highlights with matches\n\n    return self.chi2, self.match_count, self.highlight_ions\n</code></pre>"},{"location":"reference/rionid/core/#rionid.core.ImportData.detect_peaks_and_widths","title":"<code>detect_peaks_and_widths()</code>","text":"<p>Detects peaks in the experimental spectrum using scipy.signal.find_peaks.</p> <p>Updates <code>self.peak_freqs</code> and <code>self.peak_heights</code>.</p> Source code in <code>src/rionid/core.py</code> <pre><code>def detect_peaks_and_widths(self):\n    \"\"\"\n    Detects peaks in the experimental spectrum using scipy.signal.find_peaks.\n\n    Updates `self.peak_freqs` and `self.peak_heights`.\n    \"\"\"\n    if self.experimental_data is None: return\n    freq, amp = self.experimental_data\n\n    rel_height = max(0.0, min(self.peak_threshold_pct, 1.0))\n    height_thresh = np.max(amp) * rel_height\n\n    peaks, _ = find_peaks(\n        amp,\n        height=height_thresh,\n        distance=self.min_distance,\n        prominence=height_thresh * 0.2,\n        width=1\n    )\n\n    # Filter by frequency window\n    peak_freqs = freq[peaks]\n    mask = np.ones_like(peaks, dtype=bool)\n    if self.matching_freq_min is not None:\n        mask &amp;= (peak_freqs &gt;= self.matching_freq_min)\n    if self.matching_freq_max is not None:\n        mask &amp;= (peak_freqs &lt;= self.matching_freq_max)\n\n    self.peak_freqs = peak_freqs[mask]\n    self.peak_heights = amp[peaks][mask]\n    self.peak_widths_freq = np.zeros_like(self.peak_freqs) \n</code></pre>"},{"location":"reference/rionid/core/#rionid.core.ImportData.reference_frequency","title":"<code>reference_frequency(fref=None, brho=None, ke=None, gam=None)</code>","text":"<p>Determines the reference frequency based on input mode.</p> Source code in <code>src/rionid/core.py</code> <pre><code>def reference_frequency(self, fref=None, brho=None, ke=None, gam=None):\n    \"\"\"Determines the reference frequency based on input mode.\"\"\"\n    if fref: return fref\n    elif brho: return ImportData.calc_ref_rev_frequency(self.ref_mass, self.ring.circumference, brho=brho, ref_charge=self.ref_charge)\n    elif ke: return ImportData.calc_ref_rev_frequency(self.ref_mass, self.ring.circumference, ke=ke, aa=self.ref_aa)\n    elif gam: return ImportData.calc_ref_rev_frequency(self.ref_mass, self.ring.circumference, gam=gam)\n    else: sys.exit('Error: No reference parameter provided.')\n</code></pre>"},{"location":"reference/rionid/core/#rionid.core.ImportData.save_matched_result","title":"<code>save_matched_result(filename)</code>","text":"<p>Saves the list of matched ions to a text file.</p> Source code in <code>src/rionid/core.py</code> <pre><code>def save_matched_result(self, filename):\n    \"\"\"Saves the list of matched ions to a text file.\"\"\"\n    if not filename or not self.highlight_ions: return\n    with open(filename, 'w') as f:\n        f.write(\"Matched Ions List\\n\")\n        for ion in self.highlight_ions:\n            f.write(f\"{ion}\\n\")\n    print(f\"Matched results saved to {filename}\")\n</code></pre>"},{"location":"reference/rionid/io/","title":"Io","text":""},{"location":"reference/rionid/io/#rionid.io","title":"<code>rionid.io</code>","text":""},{"location":"reference/rionid/io/#rionid.io.handle_prerionidnpz_data","title":"<code>handle_prerionidnpz_data(filename)</code>","text":"<p>Handles legacy PreRionID NPZ files using 'x' and 'y' keys.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the .npz file.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>(frequency_array, amplitude_array)</p> Source code in <code>src/rionid/io.py</code> <pre><code>def handle_prerionidnpz_data(filename):\n    \"\"\"\n    Handles legacy PreRionID NPZ files using 'x' and 'y' keys.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the .npz file.\n\n    Returns\n    -------\n    tuple\n        (frequency_array, amplitude_array)\n    \"\"\"\n    data = np.load(filename)\n    frequency = data['x']\n    amplitude = data['y']\n    return frequency, amplitude\n</code></pre>"},{"location":"reference/rionid/io/#rionid.io.handle_read_tdsm_bin","title":"<code>handle_read_tdsm_bin(path)</code>","text":"<p>Wrapper for reading TDSM binary files and averaging the amplitude.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the binary file set.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>(frequency_array, averaged_amplitude_array)</p> Source code in <code>src/rionid/io.py</code> <pre><code>def handle_read_tdsm_bin(path):\n    \"\"\"\n    Wrapper for reading TDSM binary files and averaging the amplitude.\n\n    Parameters\n    ----------\n    path : str\n        Path to the binary file set.\n\n    Returns\n    -------\n    tuple\n        (frequency_array, averaged_amplitude_array)\n    \"\"\"\n    frequency, _, amplitude = read_tdsm_bin(path)\n    amplitude_avg = np.average(amplitude, axis=0)\n    return frequency, amplitude_avg\n</code></pre>"},{"location":"reference/rionid/io/#rionid.io.handle_spectrumnpz_data","title":"<code>handle_spectrumnpz_data(filename, frequency_key='arr_0', amplitude_key='arr_1', **kwargs)</code>","text":"<p>Handles simple 1D Spectrum NPZ files.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the .npz file.</p> required <code>frequency_key</code> <code>str</code> <p>Key for frequency array. Default 'arr_0'.</p> <code>'arr_0'</code> <code>amplitude_key</code> <code>str</code> <p>Key for amplitude array. Default 'arr_1'.</p> <code>'arr_1'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(frequency_array, amplitude_array)</p> Source code in <code>src/rionid/io.py</code> <pre><code>def handle_spectrumnpz_data(filename, frequency_key='arr_0', amplitude_key='arr_1', **kwargs):\n    \"\"\"\n    Handles simple 1D Spectrum NPZ files.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the .npz file.\n    frequency_key : str, optional\n        Key for frequency array. Default 'arr_0'.\n    amplitude_key : str, optional\n        Key for amplitude array. Default 'arr_1'.\n\n    Returns\n    -------\n    tuple\n        (frequency_array, amplitude_array)\n    \"\"\"\n    data = np.load(filename)\n    return data[frequency_key].flatten(), data[amplitude_key]\n</code></pre>"},{"location":"reference/rionid/io/#rionid.io.handle_tiqnpz_data","title":"<code>handle_tiqnpz_data(filename, frequency_key='arr_0', amplitude_key='arr_2', time_key='arr_1', **kwargs)</code>","text":"<p>Handles standard IQTools NPZ files (Time-Frequency-Amplitude).</p> <p>This function averages the amplitude over time. Note: It skips the first 5 time slices (<code>amp[5:,:]</code>) to avoid startup artifacts/shifts.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the .npz file.</p> required <code>frequency_key</code> <code>str</code> <p>Key for frequency array. Default 'arr_0'.</p> <code>'arr_0'</code> <code>amplitude_key</code> <code>str</code> <p>Key for amplitude matrix. Default 'arr_2'.</p> <code>'arr_2'</code> <code>time_key</code> <code>str</code> <p>Key for time array. Default 'arr_1'.</p> <code>'arr_1'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(frequency_array, averaged_amplitude_array)</p> Source code in <code>src/rionid/io.py</code> <pre><code>def handle_tiqnpz_data(filename, frequency_key='arr_0', amplitude_key='arr_2', time_key='arr_1', **kwargs):\n    \"\"\"\n    Handles standard IQTools NPZ files (Time-Frequency-Amplitude).\n\n    This function averages the amplitude over time.\n    Note: It skips the first 5 time slices (`amp[5:,:]`) to avoid startup artifacts/shifts.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the .npz file.\n    frequency_key : str, optional\n        Key for frequency array. Default 'arr_0'.\n    amplitude_key : str, optional\n        Key for amplitude matrix. Default 'arr_2'.\n    time_key : str, optional\n        Key for time array. Default 'arr_1'.\n\n    Returns\n    -------\n    tuple\n        (frequency_array, averaged_amplitude_array)\n    \"\"\"\n    data = np.load(filename)\n    freq = data[frequency_key].flatten()\n    amp = data[amplitude_key]\n\n    # Averaging from index 5 onwards to remove potential startup artifacts\n    amplitude_average = np.average(amp[5:,:], axis=0) \n    return freq, amplitude_average\n</code></pre>"},{"location":"reference/rionid/io/#rionid.io.read_psdata","title":"<code>read_psdata(filename, dbm=False)</code>","text":"<p>Reads generic CSV/TXT spectrum files.</p> <p>Assumes a pipe-delimited format ('|').</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the file.</p> required <code>dbm</code> <code>bool</code> <p>If True, reads the 3rd column (index 2). If False, reads the 2nd column (index 1). Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(frequency_array, amplitude_array)</p> Source code in <code>src/rionid/io.py</code> <pre><code>def read_psdata(filename, dbm=False):\n    \"\"\"\n    Reads generic CSV/TXT spectrum files.\n\n    Assumes a pipe-delimited format ('|').\n\n    Parameters\n    ----------\n    filename : str\n        Path to the file.\n    dbm : bool, optional\n        If True, reads the 3rd column (index 2). If False, reads the 2nd column (index 1).\n        Default is False.\n\n    Returns\n    -------\n    tuple\n        (frequency_array, amplitude_array)\n    \"\"\"\n    if dbm: \n        frequency, amplitude = np.genfromtxt(filename, skip_header=1, delimiter='|', usecols=(0,2))\n    else: \n        frequency, amplitude = np.genfromtxt(filename, skip_header=1, delimiter='|', usecols=(0,1))\n\n    return frequency, amplitude\n</code></pre>"},{"location":"reference/rionid/io/#rionid.io.read_tdsm_bin","title":"<code>read_tdsm_bin(path)</code>","text":"<p>Reads custom binary TDSM files (.bin_fre, .bin_time, .bin_amp).</p> <p>This function expects three files to exist with the same base name but different extensions. It uses memory mapping for the amplitude file to handle large datasets efficiently. It also performs an FFT shift operation (swapping halves) on the frequency and amplitude arrays.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path (extension is ignored, base name is used).</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>(frequency_array, time_array, amplitude_matrix)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If files cannot be read or dimensions are inconsistent.</p> Source code in <code>src/rionid/io.py</code> <pre><code>def read_tdsm_bin(path):\n    \"\"\"\n    Reads custom binary TDSM files (.bin_fre, .bin_time, .bin_amp).\n\n    This function expects three files to exist with the same base name but different\n    extensions. It uses memory mapping for the amplitude file to handle large datasets efficiently.\n    It also performs an FFT shift operation (swapping halves) on the frequency and amplitude arrays.\n\n    Parameters\n    ----------\n    path : str\n        The file path (extension is ignored, base name is used).\n\n    Returns\n    -------\n    tuple\n        (frequency_array, time_array, amplitude_matrix)\n\n    Raises\n    ------\n    Exception\n        If files cannot be read or dimensions are inconsistent.\n    \"\"\"\n    base_path, _ = os.path.splitext(path)\n    bin_fre_path = os.path.join(base_path + '.bin_fre')\n    bin_time_path = os.path.join(base_path + '.bin_time')\n    bin_amp_path = os.path.join(base_path + '.bin_amp')\n\n    try:\n        fre = np.fromfile(bin_fre_path, dtype=np.float64)\n        time = np.fromfile(bin_time_path, dtype=np.float32)\n        amp = np.memmap(bin_amp_path, dtype=np.float32, mode='r', shape=(len(time), len(fre)))\n    except IOError as e:\n        raise Exception(f\"Error reading files: {e}\")\n\n    if len(time) == 0 or len(fre) == 0:\n        raise ValueError(\"Time or frequency data files are empty\")\n\n    try:\n        amp = amp.reshape((len(time), len(fre)))\n    except ValueError as e:\n        raise ValueError(f\"Amplitude data cannot be reshaped: {e}\")\n\n    midpoint = len(fre) // 2\n    frequency = np.concatenate((fre[midpoint:], fre[:midpoint]))\n    amplitude = np.concatenate((amp[:, midpoint:], amp[:, :midpoint]), axis=1)\n\n    return frequency, time, amplitude\n</code></pre>"},{"location":"reference/rionid/io/#rionid.io.write_arrays_to_ods","title":"<code>write_arrays_to_ods(file_name, sheet_name, names, *arrays)</code>","text":"<p>Writes data arrays to an OpenDocument Spreadsheet (.ods).</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Output filename.</p> required <code>sheet_name</code> <code>str</code> <p>Name of the sheet to create.</p> required <code>names</code> <code>list of str</code> <p>List of column headers.</p> required <code>*arrays</code> <code>list of array-like</code> <p>Variable number of arrays to write as columns.</p> <code>()</code> Source code in <code>src/rionid/io.py</code> <pre><code>def write_arrays_to_ods(file_name, sheet_name, names, *arrays):\n    \"\"\"\n    Writes data arrays to an OpenDocument Spreadsheet (.ods).\n\n    Parameters\n    ----------\n    file_name : str\n        Output filename.\n    sheet_name : str\n        Name of the sheet to create.\n    names : list of str\n        List of column headers.\n    *arrays : list of array-like\n        Variable number of arrays to write as columns.\n    \"\"\"\n    # Create the ods spreadsheet and add a sheet\n    spreadsheet = ezodf.newdoc(doctype='ods', filename=file_name)\n    max_len = max(len(arr) for arr in arrays)\n    sheet = ezodf.Sheet(sheet_name, size=(max_len+1, len(arrays)))\n    spreadsheet.sheets += sheet\n\n    for i, arr in enumerate(arrays):\n        sheet[(0, i)].set_value(str(names[i]))\n        for j in range(len(arr)):\n            sheet[j+1, i].set_value(arr[j])\n\n    # Save the spreadsheet\n    spreadsheet.save()\n</code></pre>"},{"location":"reference/rionid/version/","title":"Version","text":""},{"location":"reference/rionid/version/#rionid.version","title":"<code>rionid.version</code>","text":""},{"location":"reference/rionid/gui/","title":"Index","text":""},{"location":"reference/rionid/gui/#rionid.gui","title":"<code>rionid.gui</code>","text":""},{"location":"reference/rionid/gui/app/","title":"App","text":""},{"location":"reference/rionid/gui/app/#rionid.gui.app","title":"<code>rionid.gui.app</code>","text":""},{"location":"reference/rionid/gui/app/#rionid.gui.app.MainWindow","title":"<code>MainWindow</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>The main application window for RionID.</p> <p>This class acts as the central container, arranging the input parameters panel (left) and the visualization plot (right) using a QSplitter. It handles the signal connections between the input logic and the plotting display.</p> <p>Attributes:</p> Name Type Description <code>visualization_widget</code> <code>CreatePyGUI</code> <p>The right-hand panel containing the PyQtGraph plot.</p> <code>rion_input</code> <code>RionID_GUI</code> <p>The left-hand panel containing input fields and control buttons.</p> Source code in <code>src/rionid/gui/app.py</code> <pre><code>class MainWindow(QWidget):\n    \"\"\"\n    The main application window for RionID.\n\n    This class acts as the central container, arranging the input parameters panel\n    (left) and the visualization plot (right) using a QSplitter. It handles the\n    signal connections between the input logic and the plotting display.\n\n    Attributes\n    ----------\n    visualization_widget : CreatePyGUI\n        The right-hand panel containing the PyQtGraph plot.\n    rion_input : RionID_GUI\n        The left-hand panel containing input fields and control buttons.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the main window, sets geometry, and connects signals.\n        \"\"\"\n        super().__init__()\n        self.setWindowTitle(\"RionID\")\n\n        screen = QApplication.primaryScreen()\n        screen_geom = screen.availableGeometry()\n        width = int(screen_geom.width() * 0.8)\n        height = int(screen_geom.height() * 0.8)\n\n        # Center the window\n        x = (screen_geom.width() - width) // 2\n        y = (screen_geom.height() - height) // 2\n        self.setGeometry(x, y, width, height)   \n\n        # Create a QSplitter to hold both the input and the visualization\n        splitter = QSplitter(Qt.Horizontal)\n\n        # Create Visualization Widget FIRST\n        # We must create this first because rion_input needs a reference to it\n        # to handle the 'Pick' cursor events.\n        self.visualization_widget = CreatePyGUI()\n\n        # 2. Create Input Widget\n        # Pass the plot widget so inputs can trigger cursor picking\n        self.rion_input = RionID_GUI(plot_widget=self.visualization_widget)\n\n        # Add widgets to the splitter\n        splitter.addWidget(self.rion_input)\n        splitter.addWidget(self.visualization_widget)\n\n        # Set initial size ratios (1 part input, 2 parts plot)\n        splitter.setStretchFactor(0, 1)  \n        splitter.setStretchFactor(1, 2) \n\n        # Create the main layout\n        layout = QVBoxLayout()\n        layout.addWidget(splitter)\n        self.setLayout(layout)\n\n        # --- Signal Connections ---\n\n        # 1. Update plot when a full simulation run finishes\n        self.rion_input.visualization_signal.connect(self.update_visualization)\n\n        # 2. Overlay specific simulation (used for Quick PID visual feedback loop)\n        self.rion_input.overlay_sim_signal.connect(self.overlay_simulation)\n\n        # 3. Handle plot clicks (used to stop Quick PID loops or pick coordinates)\n        self.visualization_widget.plotClicked.connect(self.rion_input.onPlotClicked)\n\n    def update_visualization(self, data):\n        \"\"\"\n        Updates the visualization widget with new experimental and simulated data.\n\n        This slot is triggered when a full simulation run is completed. It replaces\n        all existing data on the plot (experimental and simulated).\n\n        Parameters\n        ----------\n        data : ImportData\n            The data object containing experimental spectrum arrays and\n            simulated ion frequency dictionaries.\n        \"\"\"\n        self.visualization_widget.updateData(data)\n\n    def overlay_simulation(self, data):\n        \"\"\"\n        Overlays a specific simulation result onto the existing plot.\n\n        This is primarily used during the 'Quick PID' scan to show visual feedback\n        of the fitting process without reloading or clearing the heavy experimental \n        data every frame. It clears previous simulation lines but keeps the \n        experimental spectrum.\n\n        Parameters\n        ----------\n        data : ImportData\n            The data object containing the specific simulation iteration to display.\n        \"\"\"\n        self.visualization_widget.clear_simulated_data()\n        self.visualization_widget.plot_simulated_data(data)\n</code></pre>"},{"location":"reference/rionid/gui/app/#rionid.gui.app.MainWindow.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the main window, sets geometry, and connects signals.</p> Source code in <code>src/rionid/gui/app.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the main window, sets geometry, and connects signals.\n    \"\"\"\n    super().__init__()\n    self.setWindowTitle(\"RionID\")\n\n    screen = QApplication.primaryScreen()\n    screen_geom = screen.availableGeometry()\n    width = int(screen_geom.width() * 0.8)\n    height = int(screen_geom.height() * 0.8)\n\n    # Center the window\n    x = (screen_geom.width() - width) // 2\n    y = (screen_geom.height() - height) // 2\n    self.setGeometry(x, y, width, height)   \n\n    # Create a QSplitter to hold both the input and the visualization\n    splitter = QSplitter(Qt.Horizontal)\n\n    # Create Visualization Widget FIRST\n    # We must create this first because rion_input needs a reference to it\n    # to handle the 'Pick' cursor events.\n    self.visualization_widget = CreatePyGUI()\n\n    # 2. Create Input Widget\n    # Pass the plot widget so inputs can trigger cursor picking\n    self.rion_input = RionID_GUI(plot_widget=self.visualization_widget)\n\n    # Add widgets to the splitter\n    splitter.addWidget(self.rion_input)\n    splitter.addWidget(self.visualization_widget)\n\n    # Set initial size ratios (1 part input, 2 parts plot)\n    splitter.setStretchFactor(0, 1)  \n    splitter.setStretchFactor(1, 2) \n\n    # Create the main layout\n    layout = QVBoxLayout()\n    layout.addWidget(splitter)\n    self.setLayout(layout)\n\n    # --- Signal Connections ---\n\n    # 1. Update plot when a full simulation run finishes\n    self.rion_input.visualization_signal.connect(self.update_visualization)\n\n    # 2. Overlay specific simulation (used for Quick PID visual feedback loop)\n    self.rion_input.overlay_sim_signal.connect(self.overlay_simulation)\n\n    # 3. Handle plot clicks (used to stop Quick PID loops or pick coordinates)\n    self.visualization_widget.plotClicked.connect(self.rion_input.onPlotClicked)\n</code></pre>"},{"location":"reference/rionid/gui/app/#rionid.gui.app.MainWindow.overlay_simulation","title":"<code>overlay_simulation(data)</code>","text":"<p>Overlays a specific simulation result onto the existing plot.</p> <p>This is primarily used during the 'Quick PID' scan to show visual feedback of the fitting process without reloading or clearing the heavy experimental  data every frame. It clears previous simulation lines but keeps the  experimental spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ImportData</code> <p>The data object containing the specific simulation iteration to display.</p> required Source code in <code>src/rionid/gui/app.py</code> <pre><code>def overlay_simulation(self, data):\n    \"\"\"\n    Overlays a specific simulation result onto the existing plot.\n\n    This is primarily used during the 'Quick PID' scan to show visual feedback\n    of the fitting process without reloading or clearing the heavy experimental \n    data every frame. It clears previous simulation lines but keeps the \n    experimental spectrum.\n\n    Parameters\n    ----------\n    data : ImportData\n        The data object containing the specific simulation iteration to display.\n    \"\"\"\n    self.visualization_widget.clear_simulated_data()\n    self.visualization_widget.plot_simulated_data(data)\n</code></pre>"},{"location":"reference/rionid/gui/app/#rionid.gui.app.MainWindow.update_visualization","title":"<code>update_visualization(data)</code>","text":"<p>Updates the visualization widget with new experimental and simulated data.</p> <p>This slot is triggered when a full simulation run is completed. It replaces all existing data on the plot (experimental and simulated).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ImportData</code> <p>The data object containing experimental spectrum arrays and simulated ion frequency dictionaries.</p> required Source code in <code>src/rionid/gui/app.py</code> <pre><code>def update_visualization(self, data):\n    \"\"\"\n    Updates the visualization widget with new experimental and simulated data.\n\n    This slot is triggered when a full simulation run is completed. It replaces\n    all existing data on the plot (experimental and simulated).\n\n    Parameters\n    ----------\n    data : ImportData\n        The data object containing experimental spectrum arrays and\n        simulated ion frequency dictionaries.\n    \"\"\"\n    self.visualization_widget.updateData(data)\n</code></pre>"},{"location":"reference/rionid/gui/app/#rionid.gui.app.main","title":"<code>main()</code>","text":"<p>The main entry point for the RionID GUI application.</p> <p>Initializes the QApplication, creates the MainWindow, and starts the Qt event loop.</p> Source code in <code>src/rionid/gui/app.py</code> <pre><code>def main():\n    \"\"\"\n    The main entry point for the RionID GUI application.\n\n    Initializes the QApplication, creates the MainWindow, and starts the\n    Qt event loop.\n    \"\"\"\n    app = QApplication(sys.argv)\n    main_window = MainWindow()\n    main_window.show()\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"reference/rionid/gui/controller/","title":"Controller","text":""},{"location":"reference/rionid/gui/controller/#rionid.gui.controller","title":"<code>rionid.gui.controller</code>","text":""},{"location":"reference/rionid/gui/controller/#rionid.gui.controller.display_nions","title":"<code>display_nions(nions, yield_data, nuclei_names, simulated_data_dict, ref_ion, harmonics)</code>","text":"<p>Filters the simulated data to retain only the top N ions based on yield.</p> <p>This function modifies the <code>simulated_data_dict</code> in-place. It ensures that the Reference Ion is always included in the list, even if its yield is low.</p> <p>Parameters:</p> Name Type Description Default <code>nions</code> <code>int</code> <p>The number of ions to keep.</p> required <code>yield_data</code> <code>array - like</code> <p>Array of yield values for all simulated ions.</p> required <code>nuclei_names</code> <code>array - like</code> <p>Array of ion names corresponding to the yield data.</p> required <code>simulated_data_dict</code> <code>dict</code> <p>Dictionary mapping harmonic numbers to simulation arrays.</p> required <code>ref_ion</code> <code>str</code> <p>The name of the reference ion (e.g., '72Ge+35').</p> required <code>harmonics</code> <code>list of float</code> <p>The list of harmonics being simulated.</p> required Source code in <code>src/rionid/gui/controller.py</code> <pre><code>def display_nions(nions, yield_data, nuclei_names, simulated_data_dict, ref_ion, harmonics):\n    \"\"\"\n    Filters the simulated data to retain only the top N ions based on yield.\n\n    This function modifies the `simulated_data_dict` in-place. It ensures that\n    the Reference Ion is always included in the list, even if its yield is low.\n\n    Parameters\n    ----------\n    nions : int\n        The number of ions to keep.\n    yield_data : array-like\n        Array of yield values for all simulated ions.\n    nuclei_names : array-like\n        Array of ion names corresponding to the yield data.\n    simulated_data_dict : dict\n        Dictionary mapping harmonic numbers to simulation arrays.\n    ref_ion : str\n        The name of the reference ion (e.g., '72Ge+35').\n    harmonics : list of float\n        The list of harmonics being simulated.\n    \"\"\"\n    # 1. Get indices of the top N ions\n    sorted_indices = argsort(yield_data)[::-1][:nions]\n\n    # 2. Find the index of the reference ion\n    ref_index = where(nuclei_names == ref_ion)[0]\n\n    # 3. FIX: Check if ref_index is not empty AND if the scalar index is missing\n    if ref_index.size &gt; 0 and ref_index[0] not in sorted_indices:\n        sorted_indices = append(sorted_indices, ref_index[0])\n\n    # 4. Filter the names\n    nuclei_names = nuclei_names[sorted_indices]\n\n    # 5. Filter the simulated data for each harmonic\n    for harmonic in harmonics: \n        name = f'{harmonic}'\n        if name in simulated_data_dict:\n            simulated_data_dict[name] = simulated_data_dict[name][sorted_indices]\n</code></pre>"},{"location":"reference/rionid/gui/controller/#rionid.gui.controller.import_controller","title":"<code>import_controller(datafile=None, filep=None, alphap=None, refion=None, harmonics=None, nions=None, amplitude=None, circumference=None, mode=None, value=None, reload_data=None, remove_baseline=False, psd_baseline_removed_l=1000000.0, peak_threshold_pct=0.05, min_distance=10, highlight_ions=None, io_params=None, sim_scalingfactor=None, matching_freq_min=None, matching_freq_max=None, correct=None)</code>","text":"<p>Main orchestration function for the RionID simulation workflow.</p> <p>This function acts as the bridge between the GUI/CLI inputs and the physics core. It initializes the <code>ImportData</code> model, loads experimental data, performs the  physics calculations (mass-to-charge, revolution frequencies), runs the  simulation, and saves the results to disk.</p> <p>Parameters:</p> Name Type Description Default <code>datafile</code> <code>str</code> <p>Path to the experimental data file (.npz, .csv, .root, etc.).</p> <code>None</code> <code>filep</code> <code>str</code> <p>Path to the particle list file (e.g., LISE++ .lpp output).</p> <code>None</code> <code>alphap</code> <code>float</code> <p>Momentum compaction factor of the ring. If the value provided is &gt; 1,  it is treated as Gamma Transition (gamma_t) and converted automatically  via <code>alphap = 1 / gamma_t^2</code>.</p> <code>None</code> <code>refion</code> <code>str</code> <p>The reference ion string in the format 'AAEl+QQ' (e.g., '72Ge+35').</p> <code>None</code> <code>harmonics</code> <code>str or list of float</code> <p>Harmonic numbers to simulate. Can be a list or a space/comma-separated string.</p> <code>None</code> <code>nions</code> <code>int</code> <p>If provided, filters the output to show only the top <code>nions</code> species  sorted by yield (plus the reference ion).</p> <code>None</code> <code>amplitude</code> <code>int</code> <p>Display option for spectral lines (0 for constant height, 1 for scaled).</p> <code>None</code> <code>circumference</code> <code>float</code> <p>Ring circumference in meters.</p> <code>None</code> <code>mode</code> <code>str</code> <p>The operation mode. Options: 'Frequency', 'Brho', 'Kinetic Energy', 'Gamma'.</p> <code>None</code> <code>value</code> <code>float</code> <p>The numerical value corresponding to the selected <code>mode</code> (e.g., the  reference frequency in Hz if mode is 'Frequency').</p> <code>None</code> <code>reload_data</code> <code>bool</code> <p>If True, reloads experimental data from the raw file; otherwise loads  from the cached .npz.</p> <code>None</code> <code>remove_baseline</code> <code>bool</code> <p>If True, applies baseline subtraction algorithms to the experimental spectrum.</p> <code>False</code> <code>psd_baseline_removed_l</code> <code>float</code> <p>The smoothness parameter (lambda) for the baseline subtraction algorithm (BrPLS). Default is 1e6.</p> <code>1000000.0</code> <code>peak_threshold_pct</code> <code>float</code> <p>Relative threshold for peak detection (0.0 to 1.0). Default is 0.05 (5%).</p> <code>0.05</code> <code>min_distance</code> <code>float</code> <p>Minimum distance (in data points) between detected peaks.</p> <code>10</code> <code>highlight_ions</code> <code>str</code> <p>Comma-separated string of ion names to highlight in the plot (e.g., '72Ge+35, 74Se+34').</p> <code>None</code> <code>io_params</code> <code>dict</code> <p>Dictionary containing specific I/O parameters (e.g., keys for NPZ files,  histogram names for ROOT files).</p> <code>None</code> <code>sim_scalingfactor</code> <code>float</code> <p>Factor to scale the simulated yield/amplitude.</p> <code>None</code> <code>matching_freq_min</code> <code>float</code> <p>Minimum frequency (Hz) bound for the peak matching algorithm.</p> <code>None</code> <code>matching_freq_max</code> <code>float</code> <p>Maximum frequency (Hz) bound for the peak matching algorithm.</p> <code>None</code> <code>correct</code> <code>list of float</code> <p>Coefficients [a0, a1, a2] for a second-order polynomial correction  applied to the simulated frequencies.</p> <code>None</code> <p>Returns:</p> Type Description <code>ImportData</code> <p>The populated data model object containing simulation results and  experimental data.</p> <code>Exception</code> <p>Returns the exception object if an error occurs during processing.</p> Source code in <code>src/rionid/gui/controller.py</code> <pre><code>def import_controller(datafile=None, filep=None, alphap=None, refion=None, harmonics=None, \n                      nions=None, amplitude=None, circumference=None, mode=None, value=None, \n                      reload_data=None, remove_baseline=False, psd_baseline_removed_l=1e6,\n                      peak_threshold_pct=0.05, min_distance=10, highlight_ions=None, \n                      io_params=None, sim_scalingfactor=None, matching_freq_min=None, \n                      matching_freq_max=None, correct=None):\n    \"\"\"\n    Main orchestration function for the RionID simulation workflow.\n\n    This function acts as the bridge between the GUI/CLI inputs and the physics core.\n    It initializes the `ImportData` model, loads experimental data, performs the \n    physics calculations (mass-to-charge, revolution frequencies), runs the \n    simulation, and saves the results to disk.\n\n    Parameters\n    ----------\n    datafile : str, optional\n        Path to the experimental data file (.npz, .csv, .root, etc.).\n    filep : str, optional\n        Path to the particle list file (e.g., LISE++ .lpp output).\n    alphap : float, optional\n        Momentum compaction factor of the ring. If the value provided is &gt; 1, \n        it is treated as Gamma Transition (gamma_t) and converted automatically \n        via `alphap = 1 / gamma_t^2`.\n    refion : str, optional\n        The reference ion string in the format 'AAEl+QQ' (e.g., '72Ge+35').\n    harmonics : str or list of float, optional\n        Harmonic numbers to simulate. Can be a list or a space/comma-separated string.\n    nions : int, optional\n        If provided, filters the output to show only the top `nions` species \n        sorted by yield (plus the reference ion).\n    amplitude : int, optional\n        Display option for spectral lines (0 for constant height, 1 for scaled).\n    circumference : float, optional\n        Ring circumference in meters.\n    mode : str, optional\n        The operation mode. Options: 'Frequency', 'Brho', 'Kinetic Energy', 'Gamma'.\n    value : float, optional\n        The numerical value corresponding to the selected `mode` (e.g., the \n        reference frequency in Hz if mode is 'Frequency').\n    reload_data : bool, optional\n        If True, reloads experimental data from the raw file; otherwise loads \n        from the cached .npz.\n    remove_baseline : bool, optional\n        If True, applies baseline subtraction algorithms to the experimental spectrum.\n    psd_baseline_removed_l : float, optional\n        The smoothness parameter (lambda) for the baseline subtraction algorithm (BrPLS).\n        Default is 1e6.\n    peak_threshold_pct : float, optional\n        Relative threshold for peak detection (0.0 to 1.0). Default is 0.05 (5%).\n    min_distance : float, optional\n        Minimum distance (in data points) between detected peaks.\n    highlight_ions : str, optional\n        Comma-separated string of ion names to highlight in the plot (e.g., '72Ge+35, 74Se+34').\n    io_params : dict, optional\n        Dictionary containing specific I/O parameters (e.g., keys for NPZ files, \n        histogram names for ROOT files).\n    sim_scalingfactor : float, optional\n        Factor to scale the simulated yield/amplitude.\n    matching_freq_min : float, optional\n        Minimum frequency (Hz) bound for the peak matching algorithm.\n    matching_freq_max : float, optional\n        Maximum frequency (Hz) bound for the peak matching algorithm.\n    correct : list of float, optional\n        Coefficients [a0, a1, a2] for a second-order polynomial correction \n        applied to the simulated frequencies.\n\n    Returns\n    -------\n    ImportData\n        The populated data model object containing simulation results and \n        experimental data.\n    Exception\n        Returns the exception object if an error occurs during processing.\n    \"\"\"\n    try:\n        # initializations\n        if float(alphap) &gt; 1: alphap = 1/float(alphap)**2 # handling alphap and gammat\n        fref = brho = ke = gam = None\n        if mode == 'Frequency': fref = float(value)\n        elif mode == 'Brho': brho = float(value)\n        elif mode == 'Kinetic Energy': ke = float(value)\n        elif mode == 'Gamma': gam = float(value)\n        # Calculations \n        mydata = ImportData(refion, float(alphap), filename=datafile, reload_data=reload_data, \n                            circumference=circumference, highlight_ions=highlight_ions,\n                            remove_baseline=remove_baseline, psd_baseline_removed_l=psd_baseline_removed_l,\n                            peak_threshold_pct=peak_threshold_pct, min_distance=min_distance,\n                            matching_freq_min=matching_freq_min, matching_freq_max=matching_freq_max,\n                            io_params=io_params)\n\n        mydata._set_particles_to_simulate_from_file(filep)\n        mydata._calculate_moqs()\n        mydata._calculate_srrf(fref=fref, brho=brho, ke=ke, gam=gam, correct=correct)\n\n        if isinstance(harmonics, str):\n            harmonics = [float(h.strip()) for h in harmonics.replace(',', ' ').split()]\n        elif not isinstance(harmonics, list):\n            harmonics = [float(harmonics)]\n\n        mydata._simulated_data(brho=brho, harmonics=harmonics, mode=mode, \n                               sim_scalingfactor=sim_scalingfactor, nions=nions)\n        # \"Outputs\"\n        if nions:\n            display_nions(int(nions), mydata.yield_data, mydata.nuclei_names, mydata.simulated_data_dict, refion, harmonics)\n\n        logger.info(f'Simulation results (ordered by frequency) will be saved to simulation_result.out')\n        sort_index = argsort(mydata.srrf)\n        # Save the results to a file with the specified format\n        save_simulation_results(mydata, mode, harmonics, sort_index)\n        logger.info(f'Succesfully saved!')\n\n        return mydata # Returns the simulated spectrum data \n\n    except Exception as e:\n        print(f\"Error during calculations: {str(e)}\")\n        raise e\n</code></pre>"},{"location":"reference/rionid/gui/controller/#rionid.gui.controller.save_simulation_results","title":"<code>save_simulation_results(mydata, mode, harmonics, sort_index, filename='simulation_result.out')</code>","text":"<p>Saves the simulation results to a formatted text file.</p> <p>Writes a table containing Ion Name, Frequency, Yield, m/q, and Mass for every simulated ion, sorted according to <code>sort_index</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mydata</code> <code>ImportData</code> <p>The data object containing the calculated physics results (srrf, moq, etc.).</p> required <code>mode</code> <code>str</code> <p>The simulation mode ('Frequency', 'Brho', etc.) used to determine how absolute frequencies are calculated.</p> required <code>harmonics</code> <code>list of float</code> <p>The list of harmonics used in the simulation.</p> required <code>sort_index</code> <code>array - like</code> <p>Indices used to sort the output (typically sorted by frequency).</p> required <code>filename</code> <code>str</code> <p>The output filename. Default is 'simulation_result.out'.</p> <code>'simulation_result.out'</code> Source code in <code>src/rionid/gui/controller.py</code> <pre><code>def save_simulation_results(mydata, mode, harmonics, sort_index, filename='simulation_result.out'):\n    \"\"\"\n    Saves the simulation results to a formatted text file.\n\n    Writes a table containing Ion Name, Frequency, Yield, m/q, and Mass for\n    every simulated ion, sorted according to `sort_index`.\n\n    Parameters\n    ----------\n    mydata : ImportData\n        The data object containing the calculated physics results (srrf, moq, etc.).\n    mode : str\n        The simulation mode ('Frequency', 'Brho', etc.) used to determine how\n        absolute frequencies are calculated.\n    harmonics : list of float\n        The list of harmonics used in the simulation.\n    sort_index : array-like\n        Indices used to sort the output (typically sorted by frequency).\n    filename : str, optional\n        The output filename. Default is 'simulation_result.out'.\n    \"\"\"\n    with open(filename, 'w') as file:\n        # Writing harmonics and brho information\n        brho = mydata.brho\n        for harmonic in harmonics:\n            header0 = f'Harmonic: {harmonic} , Bp: {brho:.6f} [Tm]'\n            logger.info(header0)\n            file.write(header0 + '\\n')\n\n        # Writing the header for the data table\n        header1 = f\"{'ion':&lt;15}{'fre[Hz]':&lt;30}{'yield [pps]':&lt;15}{'m/q [u]':&lt;15}{'m [eV]':&lt;15}\"\n        file.write(header1 + '\\n')\n        file.write('-' * len(header1) + '\\n')\n        logger.info(header1)\n\n        # Writing the sorted simulation results\n        for i in sort_index:\n            ion = mydata.nuclei_names[i]\n            if mode == 'Frequency': fre = mydata.srrf[i] * mydata.ref_frequency\n            elif mode == 'Brho': fre = mydata.srrf[i] * mydata.ref_frequency*harmonic\n            yield_ = mydata.yield_data[i]\n            moq = mydata.moq[ion]\n            mass_u = mydata.total_mass[ion]\n            mass = AMEData.to_mev(mass_u) * 1e6\n            result_line = f\"{ion:&lt;15}{fre:&lt;30.10f}{yield_:&lt;15.4e}{moq:&lt;15.12f}{mass:&lt;15.3f}\"\n            logger.info(result_line)\n            file.write(result_line + '\\n')\n</code></pre>"},{"location":"reference/rionid/gui/dialogs/","title":"Dialogs","text":""},{"location":"reference/rionid/gui/dialogs/#rionid.gui.dialogs","title":"<code>rionid.gui.dialogs</code>","text":""},{"location":"reference/rionid/gui/dialogs/#rionid.gui.dialogs.KeySelectionDialog","title":"<code>KeySelectionDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>A modal dialog for selecting data keys from a NumPy (.npz) file.</p> <p>When loading generic .npz files, the internal array names are not always standard (e.g., they might be 'arr_0', 'arr_1' or named keys like 'frequency'). This dialog prompts the user to map the available keys to the required physics data structures (Frequency and Amplitude).</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for this dialog.</p> <code>None</code> <code>keys</code> <code>list of str</code> <p>A list of string keys found in the loaded .npz file.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>freq_combo</code> <code>QComboBox</code> <p>Dropdown menu to select the key corresponding to the frequency array.</p> <code>amp_combo</code> <code>QComboBox</code> <p>Dropdown menu to select the key corresponding to the amplitude array.</p> Source code in <code>src/rionid/gui/dialogs.py</code> <pre><code>class KeySelectionDialog(QDialog):\n    \"\"\"\n    A modal dialog for selecting data keys from a NumPy (.npz) file.\n\n    When loading generic .npz files, the internal array names are not always\n    standard (e.g., they might be 'arr_0', 'arr_1' or named keys like 'frequency').\n    This dialog prompts the user to map the available keys to the required\n    physics data structures (Frequency and Amplitude).\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        The parent widget for this dialog.\n    keys : list of str, optional\n        A list of string keys found in the loaded .npz file.\n\n    Attributes\n    ----------\n    freq_combo : QComboBox\n        Dropdown menu to select the key corresponding to the frequency array.\n    amp_combo : QComboBox\n        Dropdown menu to select the key corresponding to the amplitude array.\n    \"\"\"\n\n    def __init__(self, parent=None, keys=None):\n        \"\"\"\n        Initializes the dialog, sets up the layout, and populates the selection menus.\n        \"\"\"\n        super().__init__(parent)\n        self.setWindowTitle(\"Select NPZ Keys\")\n\n        # Ensure keys is a list\n        keys = keys if keys is not None else []\n\n        layout = QVBoxLayout()\n        form = QFormLayout()\n\n        # Frequency Selection\n        self.freq_combo = QComboBox()\n        self.freq_combo.addItems(keys)\n\n        # Amplitude Selection\n        self.amp_combo = QComboBox()\n        self.amp_combo.addItems(keys)\n\n        # if 'arr_1' exists, set it as default for amplitude\n        if len(keys) &gt; 1:\n            self.amp_combo.setCurrentIndex(1)\n\n        form.addRow(\"Frequency Array:\", self.freq_combo)\n        form.addRow(\"Amplitude Array:\", self.amp_combo)\n\n        # Buttons\n        ok_btn = QPushButton(\"OK\")\n        ok_btn.clicked.connect(self.accept)\n\n        layout.addLayout(form)\n        layout.addWidget(ok_btn)\n        self.setLayout(layout)\n\n    def get_params(self):\n        \"\"\"\n        Retrieves the user's selection after the dialog is accepted.\n\n        Returns\n        -------\n        dict\n            A dictionary with the following structure:\n            {\n                'frequency_key': str,\n                'amplitude_key': str\n            }\n        \"\"\"\n        return {\n            'frequency_key': self.freq_combo.currentText(),\n            'amplitude_key': self.amp_combo.currentText()\n        }\n</code></pre>"},{"location":"reference/rionid/gui/dialogs/#rionid.gui.dialogs.KeySelectionDialog.__init__","title":"<code>__init__(parent=None, keys=None)</code>","text":"<p>Initializes the dialog, sets up the layout, and populates the selection menus.</p> Source code in <code>src/rionid/gui/dialogs.py</code> <pre><code>def __init__(self, parent=None, keys=None):\n    \"\"\"\n    Initializes the dialog, sets up the layout, and populates the selection menus.\n    \"\"\"\n    super().__init__(parent)\n    self.setWindowTitle(\"Select NPZ Keys\")\n\n    # Ensure keys is a list\n    keys = keys if keys is not None else []\n\n    layout = QVBoxLayout()\n    form = QFormLayout()\n\n    # Frequency Selection\n    self.freq_combo = QComboBox()\n    self.freq_combo.addItems(keys)\n\n    # Amplitude Selection\n    self.amp_combo = QComboBox()\n    self.amp_combo.addItems(keys)\n\n    # if 'arr_1' exists, set it as default for amplitude\n    if len(keys) &gt; 1:\n        self.amp_combo.setCurrentIndex(1)\n\n    form.addRow(\"Frequency Array:\", self.freq_combo)\n    form.addRow(\"Amplitude Array:\", self.amp_combo)\n\n    # Buttons\n    ok_btn = QPushButton(\"OK\")\n    ok_btn.clicked.connect(self.accept)\n\n    layout.addLayout(form)\n    layout.addWidget(ok_btn)\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/rionid/gui/dialogs/#rionid.gui.dialogs.KeySelectionDialog.get_params","title":"<code>get_params()</code>","text":"<p>Retrieves the user's selection after the dialog is accepted.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with the following structure: {     'frequency_key': str,     'amplitude_key': str }</p> Source code in <code>src/rionid/gui/dialogs.py</code> <pre><code>def get_params(self):\n    \"\"\"\n    Retrieves the user's selection after the dialog is accepted.\n\n    Returns\n    -------\n    dict\n        A dictionary with the following structure:\n        {\n            'frequency_key': str,\n            'amplitude_key': str\n        }\n    \"\"\"\n    return {\n        'frequency_key': self.freq_combo.currentText(),\n        'amplitude_key': self.amp_combo.currentText()\n    }\n</code></pre>"},{"location":"reference/rionid/gui/inputs/","title":"Inputs","text":""},{"location":"reference/rionid/gui/inputs/#rionid.gui.inputs","title":"<code>rionid.gui.inputs</code>","text":""},{"location":"reference/rionid/gui/inputs/#rionid.gui.inputs.RionID_GUI","title":"<code>RionID_GUI</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>The main input control panel for RionID.</p> <p>This widget handles file selection, parameter configuration, and the execution of simulation scripts (Single Run and Quick PID). It communicates with the visualization widget to handle cursor picking and plot updates.</p> Source code in <code>src/rionid/gui/inputs.py</code> <pre><code>class RionID_GUI(QWidget):\n    \"\"\"\n    The main input control panel for RionID.\n\n    This widget handles file selection, parameter configuration, and the execution\n    of simulation scripts (Single Run and Quick PID). It communicates with the\n    visualization widget to handle cursor picking and plot updates.\n    \"\"\"\n\n    visualization_signal = pyqtSignal(object)\n    overlay_sim_signal = pyqtSignal(object)\n    clear_sim_signal = pyqtSignal()\n    signalError = pyqtSignal(str)\n\n    def __init__(self, plot_widget=None):\n        super().__init__()\n        self.visualization_widget = plot_widget\n        self._stop_quick_pid = False\n        self.saved_data = None\n        self.current_io_params = {} \n        self.initUI()\n        self.load_parameters()\n        self.signalError.connect(self.show_error)\n\n    def show_error(self, msg):\n        QMessageBox.critical(self, \"Error\", msg)\n\n    def initUI(self):\n        self.scroll_area = QScrollArea()\n        self.scroll_area.setWidgetResizable(True)\n        scroll_content = QWidget()\n        self.vbox = QVBoxLayout(scroll_content)\n        self.scroll_area.setWidget(scroll_content)\n\n        main_layout = QVBoxLayout()\n        main_layout.addWidget(self.scroll_area)\n        self.setLayout(main_layout)\n\n        self.setup_file_selection()\n        self.setup_parameters()\n        self.setup_quick_pid()\n        self.setup_controls()\n\n    def load_parameters(self, filepath='parameters_cache.toml'):\n        try:\n            with open(filepath, 'r') as f:\n                p = toml.load(f)\n                self.datafile_edit.setText(p.get('datafile', ''))\n                self.filep_edit.setText(p.get('filep', ''))\n                self.alphap_edit.setText(p.get('alphap', ''))\n                self.harmonics_edit.setText(p.get('harmonics', ''))\n                self.refion_edit.setText(p.get('refion', ''))\n                self.circumference_edit.setText(p.get('circumference', ''))\n                self.highlight_ions_edit.setText(p.get('highlight_ions', ''))\n                self.mode_combo.setCurrentText(p.get('mode', 'Frequency'))\n                self.value_edit.setText(p.get('value', ''))\n                self.sim_scalingfactor_edit.setText(p.get('sim_scalingfactor', ''))\n                self.remove_baseline_checkbox.setChecked(p.get('remove_baseline_checkbox', False))\n                self.psd_baseline_removed_l_edit.setText(str(p.get('psd_baseline_removed_l', '1000000')))\n                self.peak_thresh_edit.setText(str(p.get('peak_threshold_pct', '0.05')))\n                self.min_distance_edit.setText(str(p.get('min_distance', '10')))\n                self.matching_freq_min_edit.setText(str(p.get('matching_freq_min', '')))\n                self.matching_freq_max_edit.setText(str(p.get('matching_freq_max', '')))\n                self.correction_edit.setText(p.get('correction', ''))\n                self.nions_edit.setText(p.get('nions', ''))\n                self.reload_data_checkbox.setChecked(p.get('reload_data', True))\n                self.simulation_result_edit.setText(p.get('simulation_result', ''))\n                self.matched_result_edit.setText(p.get('matched_result', ''))\n                self.alphap_min_edit.setText(p.get('alphap_min', ''))\n                self.alphap_max_edit.setText(p.get('alphap_max', ''))\n                self.alphap_step_edit.setText(p.get('alphap_step', ''))\n                self.fref_min_edit.setText(p.get('fref_min', ''))\n                self.fref_max_edit.setText(p.get('fref_max', ''))\n                self.threshold_edit.setText(p.get('threshold', '1000'))\n        except FileNotFoundError: pass \n\n    def save_parameters(self, filepath='parameters_cache.toml'):\n        p = {\n            'datafile': self.datafile_edit.text(),\n            'filep': self.filep_edit.text(),\n            'alphap': self.alphap_edit.text(),\n            'harmonics': self.harmonics_edit.text(),\n            'refion': self.refion_edit.text(),\n            'circumference': self.circumference_edit.text(),\n            'highlight_ions': self.highlight_ions_edit.text(),\n            'mode': self.mode_combo.currentText(),\n            'value': self.value_edit.text(),\n            'sim_scalingfactor': self.sim_scalingfactor_edit.text(),\n            'remove_baseline_checkbox': self.remove_baseline_checkbox.isChecked(),\n            'psd_baseline_removed_l': self.psd_baseline_removed_l_edit.text(),\n            'peak_threshold_pct': self.peak_thresh_edit.text(),\n            'min_distance': self.min_distance_edit.text(),\n            'matching_freq_min': self.matching_freq_min_edit.text(),\n            'matching_freq_max': self.matching_freq_max_edit.text(),\n            'correction': self.correction_edit.text(),\n            'nions': self.nions_edit.text(),\n            'reload_data': self.reload_data_checkbox.isChecked(),\n            'simulation_result': self.simulation_result_edit.text(),\n            'matched_result': self.matched_result_edit.text(),\n            'alphap_min': self.alphap_min_edit.text(),\n            'alphap_max': self.alphap_max_edit.text(),\n            'alphap_step': self.alphap_step_edit.text(),\n            'fref_min': self.fref_min_edit.text(),\n            'fref_max': self.fref_max_edit.text(),\n            'threshold': self.threshold_edit.text()\n        }\n        with open(filepath, 'w') as f: toml.dump(p, f)\n\n    def setup_file_selection(self):\n        self.datafile_label = QLabel('Experimental Data File:')\n        self.datafile_edit = QLineEdit()\n        self.datafile_button = QPushButton('Browse')\n        self.datafile_button.clicked.connect(self.browse_datafile)\n\n        self.filep_label = QLabel('.lpp File:')\n        self.filep_edit = QLineEdit()\n        self.filep_button = QPushButton('Browse')\n        self.filep_button.clicked.connect(self.browse_lppfile)\n\n        hb1 = QHBoxLayout()\n        hb1.addWidget(self.datafile_label)\n        hb1.addWidget(self.datafile_edit)\n        hb1.addWidget(self.datafile_button)\n        self.vbox.addLayout(hb1)\n\n        hb2 = QHBoxLayout()\n        hb2.addWidget(self.filep_label)\n        hb2.addWidget(self.filep_edit)\n        hb2.addWidget(self.filep_button)\n        self.vbox.addLayout(hb2)\n\n    def setup_parameters(self):\n        # Baseline\n        self.remove_baseline_checkbox = QCheckBox('Remove Baseline')\n        self.vbox.addWidget(self.remove_baseline_checkbox)\n\n        self.psd_baseline_removed_l_edit = QLineEdit(\"1000000\")\n        hb_bl = QHBoxLayout()\n        hb_bl.addWidget(QLabel(\"Baseline l:\"))\n        hb_bl.addWidget(self.psd_baseline_removed_l_edit)\n        self.vbox.addLayout(hb_bl)\n\n        # Alpha P\n        self.alphap_edit = QLineEdit()\n        hb_ap = QHBoxLayout()\n        hb_ap.addWidget(QLabel(\"Alpha P:\"))\n        hb_ap.addWidget(self.alphap_edit)\n        self.vbox.addLayout(hb_ap)\n\n        # Standard Params\n        self.harmonics_edit = QLineEdit()\n        self.refion_edit = QLineEdit()\n        self.circumference_edit = QLineEdit()\n        self.highlight_ions_edit = QLineEdit()\n\n        for lbl, widget in [(\"Harmonics:\", self.harmonics_edit), \n                            (\"Ref Ion:\", self.refion_edit),\n                            (\"Circumference:\", self.circumference_edit),\n                            (\"Highlight Ions:\", self.highlight_ions_edit)]:\n            h = QHBoxLayout()\n            h.addWidget(QLabel(lbl))\n            h.addWidget(widget)\n            self.vbox.addLayout(h)\n\n        # Mode\n        self.mode_combo = QComboBox()\n        self.mode_combo.addItems(['Frequency', 'B\u03c1', 'Kinetic Energy'])\n        self.value_edit = QLineEdit()\n        h_mode = QHBoxLayout()\n        h_mode.addWidget(QLabel(\"Mode:\"))\n        h_mode.addWidget(self.mode_combo)\n        h_mode.addWidget(self.value_edit)\n        self.vbox.addLayout(h_mode)\n\n        # Scaling Factor\n        self.sim_scalingfactor_edit = QLineEdit()\n        h_sf = QHBoxLayout()\n        h_sf.addWidget(QLabel(\"Scaling Factor:\"))\n        h_sf.addWidget(self.sim_scalingfactor_edit)\n        self.vbox.addLayout(h_sf)\n\n        # Peak Detection\n        self.peak_thresh_edit = QLineEdit(\"0.05\")\n        self.min_distance_edit = QLineEdit(\"10\")\n        h_peak = QHBoxLayout()\n        h_peak.addWidget(QLabel(\"Peak Thresh %:\"))\n        h_peak.addWidget(self.peak_thresh_edit)\n        h_peak.addWidget(QLabel(\"Min Dist:\"))\n        h_peak.addWidget(self.min_distance_edit)\n        self.vbox.addLayout(h_peak)\n\n        # Matching Freq Range\n        self.matching_freq_min_edit = QLineEdit()\n        self.matching_freq_max_edit = QLineEdit()\n        self.pick_matching_freq_min_button = QPushButton(\"Pick\")\n        self.pick_matching_freq_min_button.clicked.connect(lambda: self.enterPlotPickMode(self.matching_freq_min_edit))\n        self.pick_matching_freq_max_button = QPushButton(\"Pick\")\n        self.pick_matching_freq_max_button.clicked.connect(lambda: self.enterPlotPickMode(self.matching_freq_max_edit))\n\n        h_mf = QHBoxLayout()\n        h_mf.addWidget(QLabel(\"Match Freq Min:\"))\n        h_mf.addWidget(self.matching_freq_min_edit)\n        h_mf.addWidget(self.pick_matching_freq_min_button)\n        self.vbox.addLayout(h_mf)\n\n        h_mf2 = QHBoxLayout()\n        h_mf2.addWidget(QLabel(\"Match Freq Max:\"))\n        h_mf2.addWidget(self.matching_freq_max_edit)\n        h_mf2.addWidget(self.pick_matching_freq_max_button)\n        self.vbox.addLayout(h_mf2)\n\n        # Threshold for PID\n        self.threshold_edit = QLineEdit(\"1000\")\n        h_t = QHBoxLayout()\n        h_t.addWidget(QLabel(\"Match Threshold (Hz):\"))\n        h_t.addWidget(self.threshold_edit)\n        self.vbox.addLayout(h_t)\n\n        # Optional Features Group\n        self.optional_group = QGroupBox(\"Optional Features\")\n        opt_layout = QFormLayout()\n\n        self.nions_edit = QLineEdit()\n        self.nions_edit.setPlaceholderText(\"e.g. 5\")\n        opt_layout.addRow(\"N Ions to Display:\", self.nions_edit)\n\n        self.correction_edit = QLineEdit()\n        self.correction_edit.setPlaceholderText(\"a0 a1 a2\")\n        opt_layout.addRow(\"Correction (a0*x**2 + a1*x + a2):\", self.correction_edit)\n\n        self.reload_data_checkbox = QCheckBox(\"Reload Data Cache\")\n        opt_layout.addRow(self.reload_data_checkbox)\n\n        self.simulation_result_edit = QLineEdit()\n        self.matched_result_edit = QLineEdit()\n        opt_layout.addRow(\"Sim Result File:\", self.simulation_result_edit)\n        opt_layout.addRow(\"Matched Result File:\", self.matched_result_edit)\n\n        self.optional_group.setLayout(opt_layout)\n        self.vbox.addWidget(self.optional_group)\n\n    def setup_quick_pid(self):\n        group = QGroupBox(\"Quick PID\")\n        layout = QVBoxLayout()\n\n        self.alphap_min_edit = QLineEdit()\n        self.alphap_max_edit = QLineEdit()\n        self.alphap_step_edit = QLineEdit()\n\n        h_a = QHBoxLayout()\n        h_a.addWidget(QLabel(\"Alpha Range:\"))\n        h_a.addWidget(self.alphap_min_edit)\n        h_a.addWidget(self.alphap_max_edit)\n        h_a.addWidget(self.alphap_step_edit)\n        layout.addLayout(h_a)\n\n        self.fref_min_edit = QLineEdit()\n        self.fref_max_edit = QLineEdit()\n\n        pick_min = QPushButton(\"Pick\")\n        pick_min.clicked.connect(lambda: self.enterPlotPickMode(self.fref_min_edit))\n        pick_max = QPushButton(\"Pick\")\n        pick_max.clicked.connect(lambda: self.enterPlotPickMode(self.fref_max_edit))\n\n        h_f = QHBoxLayout()\n        h_f.addWidget(QLabel(\"Freq Range:\"))\n        h_f.addWidget(self.fref_min_edit)\n        h_f.addWidget(pick_min)\n        h_f.addWidget(self.fref_max_edit)\n        h_f.addWidget(pick_max)\n        layout.addLayout(h_f)\n\n        btn_pid = QPushButton(\"Run Quick PID\")\n        btn_pid.clicked.connect(self.quick_pid_script)\n        layout.addWidget(btn_pid)\n\n        group.setLayout(layout)\n        self.vbox.addWidget(group)\n\n    def setup_controls(self):\n        self.run_button = QPushButton(\"Run\")\n        self.run_button.clicked.connect(self.run_script)\n        self.vbox.addWidget(self.run_button)\n\n        self.exit_button = QPushButton(\"Exit\")\n        self.exit_button.clicked.connect(self.close_application)\n        self.vbox.addWidget(self.exit_button)\n\n    def close_application(self):\n        sys.exit()\n\n    def enterPlotPickMode(self, target):\n        if not self.visualization_widget: return\n        self._pick_target = target\n        target.setStyleSheet(\"background-color: lightgray;\")\n        self.visualization_widget.plot_widget.setCursor(Qt.CrossCursor)\n        self.visualization_widget.plotClicked.connect(self._onPlotPicked)\n\n    @pyqtSlot()\n    def _onPlotPicked(self):\n        pos = self.visualization_widget.plot_widget.mapFromGlobal(QCursor.pos())\n        point = self.visualization_widget.plot_widget.plotItem.vb.mapSceneToView(pos)\n\n        if self._pick_target:\n            self._pick_target.setText(f\"{point.x()*1e6:.2f}\") \n            self._pick_target.setStyleSheet(\"\")\n\n        self.visualization_widget.plot_widget.setCursor(Qt.ArrowCursor)\n        self.visualization_widget.plotClicked.disconnect(self._onPlotPicked)\n\n    def _get_float(self, widget, default=0.0):\n        text = widget.text().strip()\n        if not text: return default\n        try: return float(text)\n        except ValueError: return default\n\n    @pyqtSlot()\n    def onPlotClicked(self):\n        self._stop_quick_pid = True\n\n    def run_script(self):\n        datafile = self.datafile_edit.text()\n        if not datafile: return\n\n        io_params = self.current_io_params\n        ext = os.path.splitext(datafile)[1].lower()\n        if ext == '.npz' and not io_params:\n            data = np.load(datafile)\n            dlg = KeySelectionDialog(self, list(data.keys()))\n            if dlg.exec_(): \n                io_params = dlg.get_params()\n                self.current_io_params = io_params \n            else: return\n\n        correct_str = self.correction_edit.text().strip()\n        correct = [float(x) for x in correct_str.split()] if correct_str else None\n\n        sim_sf_str = self.sim_scalingfactor_edit.text().strip()\n        sim_sf = float(sim_sf_str) if sim_sf_str else None\n\n        psd_l = self._get_float(self.psd_baseline_removed_l_edit, 1000000.0)\n        peak_pct = self._get_float(self.peak_thresh_edit, 0.05)\n        min_dist = self._get_float(self.min_distance_edit, 10.0)\n        alphap = self._get_float(self.alphap_edit, 0.0)\n        circumference = self._get_float(self.circumference_edit, 0.0)\n\n        match_min_str = self.matching_freq_min_edit.text().strip()\n        match_min = float(match_min_str) if match_min_str else None\n        match_max_str = self.matching_freq_max_edit.text().strip()\n        match_max = float(match_max_str) if match_max_str else None\n\n        args = argparse.Namespace(\n            datafile=datafile,\n            filep=self.filep_edit.text(),\n            alphap=alphap,\n            harmonics=self.harmonics_edit.text(),\n            refion=self.refion_edit.text(),\n            circumference=circumference,\n            mode=self.mode_combo.currentText(),\n            value=self.value_edit.text(),\n            remove_baseline=self.remove_baseline_checkbox.isChecked(),\n            psd_baseline_removed_l=psd_l,\n            peak_threshold_pct=peak_pct,\n            min_distance=min_dist,\n            highlight_ions=self.highlight_ions_edit.text(),\n            io_params=io_params,\n            reload_data=self.reload_data_checkbox.isChecked(),\n            nions=self.nions_edit.text(),\n            sim_scalingfactor=sim_sf,\n            matching_freq_min=match_min,\n            matching_freq_max=match_max,\n            correct=correct\n        )\n\n        try:\n            self.save_parameters()\n            data = import_controller(**vars(args))\n            self.saved_data = data\n            self.visualization_signal.emit(data)\n        except Exception as e:\n            self.signalError.emit(str(e))\n\n    def quick_pid_script(self):\n        \"\"\"\n        Executes the iterative Quick PID scanning algorithm.\n\n        This method scans a range of Alpha_p values and Reference Frequencies (derived\n        from experimental peaks) to find the best match (lowest Chi-squared) between\n        simulation and experiment.\n        \"\"\"\n        try:\n            print(\"Running optimized quick_pid_script...\")\n            datafile = self.datafile_edit.text().strip()\n            if not datafile: raise ValueError(\"No experimental data provided.\")\n\n            if not self._check_io_params(datafile): return\n\n            # --- 1. Gather Constants &amp; Ranges ---\n            filep = self.filep_edit.text() or None\n            remove_baseline = self.remove_baseline_checkbox.isChecked()\n            psd_l = self._get_float(self.psd_baseline_removed_l_edit, 1000000.0)\n            peak_pct = self._get_float(self.peak_thresh_edit, 0.05)\n            min_dist = self._get_float(self.min_distance_edit, 10.0)\n            harmonics = self.harmonics_edit.text()\n            refion = self.refion_edit.text()\n            circ = self._get_float(self.circumference_edit, 0.0)\n            sim_sf = float(self.sim_scalingfactor_edit.text()) if self.sim_scalingfactor_edit.text() else None\n            reload = self.reload_data_checkbox.isChecked()\n\n            # Ranges\n            f_min = self._get_float(self.fref_min_edit, -float('inf'))\n            f_max = self._get_float(self.fref_max_edit, float('inf'))\n            alpha_min = self._get_float(self.alphap_min_edit)\n            alpha_max = self._get_float(self.alphap_max_edit)\n            alpha_step = self._get_float(self.alphap_step_edit)\n            threshold = self._get_float(self.threshold_edit, 1000.0)\n\n            if alpha_step &lt;= 0: alpha_step = 1e-5\n\n            # --- 2. HEAVY LIFTING (Done ONCE) ---\n            print(\"Loading data and calculating baseline (once)...\")\n\n            model = ImportData(\n                refion=refion, alphap=alpha_min, filename=datafile, \n                circumference=circ, remove_baseline=remove_baseline, \n                psd_baseline_removed_l=psd_l, peak_threshold_pct=peak_pct, \n                min_distance=min_dist, io_params=self.current_io_params,\n                reload_data=reload\n            )\n\n            model._set_particles_to_simulate_from_file(filep)\n            model._calculate_moqs()\n\n            if not hasattr(model, 'peak_freqs') or len(model.peak_freqs) == 0:\n                raise RuntimeError(\"No experimental peaks detected.\")\n\n            exp_peaks = [f for f in model.peak_freqs if f_min &lt;= f &lt;= f_max]\n            if not exp_peaks:\n                raise RuntimeError(\"No peaks found in the specified Freq Range.\")\n\n            if isinstance(harmonics, str):\n                harm_list = [float(h.strip()) for h in harmonics.replace(',', ' ').split()]\n            else:\n                harm_list = [float(harmonics)]\n\n            # --- 3. THE FAST LOOP ---\n            print(f\"Scanning {len(exp_peaks)} peaks x Alpha range...\")\n            self._stop_quick_pid = False\n            results = []\n\n            orig_val_style = self.value_edit.styleSheet()\n            orig_alpha_style = self.alphap_edit.styleSheet()\n\n            for f_ref in exp_peaks:\n                if self._stop_quick_pid: break\n                self.value_edit.setText(f\"{f_ref:.2f}\")\n                self.value_edit.setStyleSheet(\"background-color: #fff8b0;\")\n                QApplication.processEvents()\n\n                for alpha in np.arange(alpha_min, alpha_max + 1e-12, alpha_step):\n                    if self._stop_quick_pid: break\n\n                    # Update model parameters directly\n                    model.alphap = alpha\n                    # Recalculate Physics\n                    model._calculate_srrf(fref=f_ref)\n                    model._simulated_data(harmonics=harm_list, mode='Frequency', sim_scalingfactor=sim_sf)\n\n                    # Compute Match\n                    chi2, count, _ = model.compute_matches(threshold)\n                    results.append((f_ref, alpha, chi2, count))\n\n            self.value_edit.setStyleSheet(orig_val_style)\n            self.alphap_edit.setStyleSheet(orig_alpha_style)\n\n            # --- 4. APPLY BEST RESULT ---\n            if results:\n                # Sort by Count (desc), then Chi2 (asc)\n                best = sorted(results, key=lambda x: (-x[3], x[2]))[0]\n                best_f, best_a, best_chi, best_cnt = best\n\n                print(f\"Best: F={best_f:.2f}, A={best_a:.6f}, Matches={best_cnt}, Chi2={best_chi:.2f}\")\n                self.value_edit.setText(f\"{best_f:.2f}\")\n                self.alphap_edit.setText(f\"{best_a:.6f}\")\n\n                model.alphap = best_a\n                model._calculate_srrf(fref=best_f)\n                model._simulated_data(harmonics=harm_list, mode='Frequency', sim_scalingfactor=sim_sf)\n                model.compute_matches(threshold)\n\n                self.saved_data = model\n                self.visualization_signal.emit(model)\n                self.save_parameters()\n\n        except Exception as e:\n            self.signalError.emit(str(e))\n            import traceback\n            traceback.print_exc()\n\n    def browse_datafile(self):\n        f, _ = QFileDialog.getOpenFileName(self, \"Select Data\")\n        if f: self.datafile_edit.setText(f)\n    def browse_lppfile(self):\n        f, _ = QFileDialog.getOpenFileName(self, \"Select LPP\")\n        if f: self.filep_edit.setText(f)\n</code></pre>"},{"location":"reference/rionid/gui/inputs/#rionid.gui.inputs.RionID_GUI.quick_pid_script","title":"<code>quick_pid_script()</code>","text":"<p>Executes the iterative Quick PID scanning algorithm.</p> <p>This method scans a range of Alpha_p values and Reference Frequencies (derived from experimental peaks) to find the best match (lowest Chi-squared) between simulation and experiment.</p> Source code in <code>src/rionid/gui/inputs.py</code> <pre><code>def quick_pid_script(self):\n    \"\"\"\n    Executes the iterative Quick PID scanning algorithm.\n\n    This method scans a range of Alpha_p values and Reference Frequencies (derived\n    from experimental peaks) to find the best match (lowest Chi-squared) between\n    simulation and experiment.\n    \"\"\"\n    try:\n        print(\"Running optimized quick_pid_script...\")\n        datafile = self.datafile_edit.text().strip()\n        if not datafile: raise ValueError(\"No experimental data provided.\")\n\n        if not self._check_io_params(datafile): return\n\n        # --- 1. Gather Constants &amp; Ranges ---\n        filep = self.filep_edit.text() or None\n        remove_baseline = self.remove_baseline_checkbox.isChecked()\n        psd_l = self._get_float(self.psd_baseline_removed_l_edit, 1000000.0)\n        peak_pct = self._get_float(self.peak_thresh_edit, 0.05)\n        min_dist = self._get_float(self.min_distance_edit, 10.0)\n        harmonics = self.harmonics_edit.text()\n        refion = self.refion_edit.text()\n        circ = self._get_float(self.circumference_edit, 0.0)\n        sim_sf = float(self.sim_scalingfactor_edit.text()) if self.sim_scalingfactor_edit.text() else None\n        reload = self.reload_data_checkbox.isChecked()\n\n        # Ranges\n        f_min = self._get_float(self.fref_min_edit, -float('inf'))\n        f_max = self._get_float(self.fref_max_edit, float('inf'))\n        alpha_min = self._get_float(self.alphap_min_edit)\n        alpha_max = self._get_float(self.alphap_max_edit)\n        alpha_step = self._get_float(self.alphap_step_edit)\n        threshold = self._get_float(self.threshold_edit, 1000.0)\n\n        if alpha_step &lt;= 0: alpha_step = 1e-5\n\n        # --- 2. HEAVY LIFTING (Done ONCE) ---\n        print(\"Loading data and calculating baseline (once)...\")\n\n        model = ImportData(\n            refion=refion, alphap=alpha_min, filename=datafile, \n            circumference=circ, remove_baseline=remove_baseline, \n            psd_baseline_removed_l=psd_l, peak_threshold_pct=peak_pct, \n            min_distance=min_dist, io_params=self.current_io_params,\n            reload_data=reload\n        )\n\n        model._set_particles_to_simulate_from_file(filep)\n        model._calculate_moqs()\n\n        if not hasattr(model, 'peak_freqs') or len(model.peak_freqs) == 0:\n            raise RuntimeError(\"No experimental peaks detected.\")\n\n        exp_peaks = [f for f in model.peak_freqs if f_min &lt;= f &lt;= f_max]\n        if not exp_peaks:\n            raise RuntimeError(\"No peaks found in the specified Freq Range.\")\n\n        if isinstance(harmonics, str):\n            harm_list = [float(h.strip()) for h in harmonics.replace(',', ' ').split()]\n        else:\n            harm_list = [float(harmonics)]\n\n        # --- 3. THE FAST LOOP ---\n        print(f\"Scanning {len(exp_peaks)} peaks x Alpha range...\")\n        self._stop_quick_pid = False\n        results = []\n\n        orig_val_style = self.value_edit.styleSheet()\n        orig_alpha_style = self.alphap_edit.styleSheet()\n\n        for f_ref in exp_peaks:\n            if self._stop_quick_pid: break\n            self.value_edit.setText(f\"{f_ref:.2f}\")\n            self.value_edit.setStyleSheet(\"background-color: #fff8b0;\")\n            QApplication.processEvents()\n\n            for alpha in np.arange(alpha_min, alpha_max + 1e-12, alpha_step):\n                if self._stop_quick_pid: break\n\n                # Update model parameters directly\n                model.alphap = alpha\n                # Recalculate Physics\n                model._calculate_srrf(fref=f_ref)\n                model._simulated_data(harmonics=harm_list, mode='Frequency', sim_scalingfactor=sim_sf)\n\n                # Compute Match\n                chi2, count, _ = model.compute_matches(threshold)\n                results.append((f_ref, alpha, chi2, count))\n\n        self.value_edit.setStyleSheet(orig_val_style)\n        self.alphap_edit.setStyleSheet(orig_alpha_style)\n\n        # --- 4. APPLY BEST RESULT ---\n        if results:\n            # Sort by Count (desc), then Chi2 (asc)\n            best = sorted(results, key=lambda x: (-x[3], x[2]))[0]\n            best_f, best_a, best_chi, best_cnt = best\n\n            print(f\"Best: F={best_f:.2f}, A={best_a:.6f}, Matches={best_cnt}, Chi2={best_chi:.2f}\")\n            self.value_edit.setText(f\"{best_f:.2f}\")\n            self.alphap_edit.setText(f\"{best_a:.6f}\")\n\n            model.alphap = best_a\n            model._calculate_srrf(fref=best_f)\n            model._simulated_data(harmonics=harm_list, mode='Frequency', sim_scalingfactor=sim_sf)\n            model.compute_matches(threshold)\n\n            self.saved_data = model\n            self.visualization_signal.emit(model)\n            self.save_parameters()\n\n    except Exception as e:\n        self.signalError.emit(str(e))\n        import traceback\n        traceback.print_exc()\n</code></pre>"},{"location":"reference/rionid/gui/plot/","title":"Plot","text":""},{"location":"reference/rionid/gui/plot/#rionid.gui.plot","title":"<code>rionid.gui.plot</code>","text":""},{"location":"reference/rionid/gui/plot/#rionid.gui.plot.CreatePyGUI","title":"<code>CreatePyGUI</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>The main visualization widget for RionID.</p> Source code in <code>src/rionid/gui/plot.py</code> <pre><code>class CreatePyGUI(QMainWindow):\n    \"\"\"\n    The main visualization widget for RionID.\n    \"\"\"\n    plotClicked = pyqtSignal()\n\n    def __init__(self, exp_data=None, sim_data=None):\n        super().__init__()\n        self.saved_x_range = None  \n        self.simulated_items = []\n        self.red_triangles = None\n        self.exp_data_curve = None\n        self.font_size = 14 \n\n        pg.setConfigOptions(antialias=True)  \n        pg.setConfigOption('background', 'k') \n        pg.setConfigOption('foreground', 'w')   \n\n        self.x_exp = np.array([])\n        self.z_exp = np.array([])\n\n        self.setup_ui()\n        self.plot_widget.scene().sigMouseClicked.connect(self.on_click)\n\n    def on_click(self, event):\n        self.plotClicked.emit()\n\n    def setup_ui(self):\n        self.setWindowTitle('Schottky Signals Identifier')\n        self.main_widget = QWidget(self)\n        self.setCentralWidget(self.main_widget)\n        main_layout = QVBoxLayout(self.main_widget)\n\n        QLoggingCategory.setFilterRules('*.warning=false\\n*.critical=false')\n\n        self.plot_widget = pg.PlotWidget()\n        self.plot_widget.showGrid(x=True, y=True, alpha=0.25)\n        self.plot_widget.plotItem.ctrl.logYCheck.setChecked(True)\n        self.plot_widget.setClipToView(True) \n\n        # Style Axes\n        axis_pen = pg.mkPen(color='w', width=1.5)\n        self.plot_widget.getAxis('bottom').setPen(axis_pen)\n        self.plot_widget.getAxis('left').setPen(axis_pen)\n        self.plot_widget.getAxis('bottom').setTextPen('w')\n        self.plot_widget.getAxis('left').setTextPen('w')\n\n        self.legend = CustomLegendItem(self.font_size, offset=(-10, 10))\n        self.legend.brush = pg.mkBrush(0, 0, 0, 150) # Semi-transparent black box\n        self.legend.pen = pg.mkPen('w', width=0.5)   # White border\n        self.legend.setParentItem(self.plot_widget.graphicsItem())\n\n        main_layout.addWidget(self.plot_widget)\n\n        self.cursor_pos_label = QLabel(self)\n        self.cursor_pos_label.setStyleSheet(\"color: black; font-weight: bold;\")\n        main_layout.addWidget(self.cursor_pos_label)\n        self.proxy = pg.SignalProxy(self.plot_widget.scene().sigMouseMoved, rateLimit=60, slot=self.mouse_moved)\n\n        self.add_buttons(main_layout)\n        self.update_fonts(self.font_size)\n\n    def _sanitize_positive(self, data, floor=1e-9):\n        \"\"\"\n        Aggressively sanitizes data for Log plotting.\n        Removes NaNs, Infs, and values &lt;= 0.\n        \"\"\"\n        data = np.asanyarray(data, dtype=float)\n        # Replace NaNs and Infs with floor\n        data[~np.isfinite(data)] = floor\n        return np.maximum(data, floor)\n\n    def plot_all_data(self, data):\n        # Disable auto-range to prevent ViewBox from calculating bounds on partial data\n        self.plot_widget.disableAutoRange()\n        try:\n            self.clear_experimental_data()\n            self.clear_simulated_data()\n            self.plot_experimental_data(data)\n            self.plot_simulated_data(data)\n\n            # Restore view or auto-range if first load\n            if self.saved_x_range:\n                self.plot_widget.setXRange(*self.saved_x_range, padding=0.02)\n            else:\n                self.plot_widget.autoRange()\n        finally:\n            self.plot_widget.enableAutoRange()\n\n    def plot_experimental_data(self, data):\n        if data.experimental_data is None: return\n        self.exp_data = data.experimental_data\n\n        # Extract and Sanitize\n        self.x_exp = self.exp_data[0] * 1e-6 # Hz -&gt; MHz\n        self.z_exp = self._sanitize_positive(self.exp_data[1])\n\n        if len(self.x_exp) == 0: return\n\n        if self.saved_x_range is None:\n            self.saved_x_range = (np.min(self.x_exp), np.max(self.x_exp))\n\n        pen = pg.mkPen(color='w', width=1.0)\n        brush = pg.mkBrush(color=(255, 255, 255, 50)) # White with low opacity\n\n        # Use fillLevel matching the floor to avoid log(-inf) issues\n        self.exp_data_curve = pg.PlotCurveItem(\n            self.x_exp, self.z_exp, \n            pen=pen, \n            brush=brush, \n            fillLevel=1e-9 \n        )\n        self.plot_widget.addItem(self.exp_data_curve)\n        self.legend.addItem(self.exp_data_curve, 'Experimental Data')\n\n        # Plot Peaks\n        if hasattr(data, 'peak_freqs') and len(data.peak_freqs) &gt; 0:\n            peak_h = self._sanitize_positive(data.peak_heights)\n\n            self.red_triangles = self.plot_widget.plot(\n                data.peak_freqs * 1e-6, peak_h,\n                pen=None, \n                symbol='t1', \n                symbolBrush='#d62728', \n                symbolPen='k',\n                symbolSize=10\n            )\n            self.legend.addItem(self.red_triangles, 'Detected Peaks')\n\n    def plot_simulated_data(self, data):\n        self.simulated_data = data.simulated_data_dict\n        refion = data.ref_ion\n        highlights = data.highlight_ions or []\n\n        color_cycle = ['#1f77b4', '#17becf', '#2ca02c', '#d62728', '#9467bd', \n                       '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22']\n\n        color_ref = '#ff7f0e' # Orange for Reference\n        color_match = '#2ca02c' # Green for Matches\n\n        for i, (harmonic, sdata) in enumerate(self.simulated_data.items()):\n            # Arrays for bulk plotting (Vectorization)\n            bulk_freqs = []\n            bulk_yields = []\n\n            # Generate a unique color for this harmonic\n            color = color_cycle[i % len(color_cycle)]\n\n            for entry in sdata:\n                try:\n                    freq = float(entry[0]) * 1e-6\n                    raw_yield = float(entry[1])\n                except (ValueError, TypeError):\n                    continue\n\n                if not np.isfinite(freq): continue\n                yield_value = max(raw_yield, 1.1e-9)\n                label = entry[2]\n\n                is_highlight = label in highlights\n                is_ref = label == refion\n\n                # Determine Style\n                if is_highlight:\n                    c = color_match\n                    width = 2\n                    style = Qt.SolidLine\n                elif is_ref:\n                    c = color_ref\n                    width = 2\n                    style = Qt.DashLine\n                else:\n                    c = color\n                    # No need for width/style here, handled by bulk curve\n\n                # Create Text Label\n                # Note: Creating thousands of TextItems is still slow. \n                # Use the '-n' (nions) argument to limit this if it's still laggy.\n                match = re.match(r'(\\d+)([A-Za-z]+)(\\d+)\\+', label)\n                if match:\n                    mass, elem, charge = match.groups()\n                    new_label = self.to_superscript(mass) + elem + self.to_superscript(charge) + '\u207a'\n                else: \n                    new_label = label\n\n                text_item = pg.TextItem(text=new_label, color=c, anchor=(0.5, 1))\n                text_item.setFont(QFont(\"Arial\", self.font_size))\n                text_item.setPos(freq, yield_value * 1.05)\n                self.plot_widget.addItem(text_item)\n\n                if is_highlight or is_ref:\n                    # Plot SPECIAL lines individually (so they draw on top with specific styles)\n                    line = self.plot_widget.plot(\n                        [freq, freq], [1e-9, yield_value], \n                        pen=pg.mkPen(color=c, width=width, style=style)\n                    )\n                    self.simulated_items.append((line, text_item))\n                else:\n                    # Add STANDARD lines to bulk arrays for optimization\n                    bulk_freqs.append(freq)\n                    bulk_yields.append(yield_value)\n                    # Track text item (line is None because it's part of the bulk curve)\n                    self.simulated_items.append((None, text_item))\n\n            # --- BULK PLOT ---\n            # Draw all standard lines for this harmonic in ONE go\n            if bulk_freqs:\n                # Interleave arrays for connect='pairs'\n                # x: [f1, f1, f2, f2, ...]\n                # y: [min, y1, min, y2, ...]\n                x_conn = np.repeat(bulk_freqs, 2)\n                y_conn = np.empty(len(bulk_yields) * 2)\n                y_conn[0::2] = 1e-9\n                y_conn[1::2] = bulk_yields\n\n                bulk_pen = pg.mkPen(color=color, width=2, style=Qt.DotLine)\n\n                # connect='pairs' tells PyQtGraph to draw disjoint lines: (p0-&gt;p1), (p2-&gt;p3), etc.\n                bulk_curve = pg.PlotCurveItem(x_conn, y_conn, connect='pairs', pen=bulk_pen)\n                self.plot_widget.addItem(bulk_curve)\n\n                # Track the bulk curve so we can clear it later\n                self.simulated_items.append((bulk_curve, None))\n\n                # Add to legend\n                self.legend.addItem(bulk_curve, f'Harmonic {harmonic}')\n\n    def to_superscript(self, s):\n        supers = {'0': '\u2070', '1': '\u00b9', '2': '\u00b2', '3': '\u00b3', '4': '\u2074', '5': '\u2075', '6': '\u2076', '7': '\u2077', '8': '\u2078', '9': '\u2079'}\n        return ''.join(supers.get(c, c) for c in s)\n\n    def update_fonts(self, size):\n        self.font_size = size\n        self.font_ticks = QFont(\"Arial\", size)\n        self.plot_widget.getAxis('bottom').setTickFont(self.font_ticks)\n        self.plot_widget.getAxis('left').setTickFont(self.font_ticks)\n\n        label_style = {'color': '#000', 'font-size': f'{size+2}pt'}\n        self.plot_widget.setLabel('bottom', 'Frequency (MHz)', **label_style)\n        self.plot_widget.setLabel('left', 'Amplitude (a.u.)', **label_style)\n\n        self.legend.updateFont(size)\n\n    def mouse_moved(self, evt):\n        pos = evt[0]\n        if self.plot_widget.sceneBoundingRect().contains(pos):\n            mousePoint = self.plot_widget.plotItem.vb.mapSceneToView(pos)\n            self.cursor_pos_label.setText(f\"Cursor: {mousePoint.x():.4f} MHz\")\n\n    def updateData(self, data):\n        self.plot_all_data(data)\n\n    def clear_simulated_data(self):\n        while self.simulated_items:\n            line, text = self.simulated_items.pop()\n            if line: \n                self.plot_widget.removeItem(line)\n            if text: \n                self.plot_widget.removeItem(text)\n        self.legend.clear()\n\n    def clear_experimental_data(self):\n        if self.exp_data_curve:\n            self.plot_widget.removeItem(self.exp_data_curve)\n            self.exp_data_curve = None\n\n        if self.red_triangles:\n            self.plot_widget.removeItem(self.red_triangles)\n            self.red_triangles = None\n\n    def reset_view(self):\n        if self.saved_x_range:\n            self.plot_widget.setXRange(*self.saved_x_range, padding=0.02)\n\n        if len(self.z_exp) &gt; 0:\n            min_y = np.min(self.z_exp)\n            max_y = np.max(self.z_exp)\n            if min_y &lt;= 0: min_y = 1e-9\n            self.plot_widget.setYRange(min_y, max_y * 2, padding=0.05)\n\n    def add_buttons(self, main_layout):\n        layout = QHBoxLayout()\n\n        font_spin = QSpinBox()\n        font_spin.setRange(8, 30)\n        font_spin.setValue(self.font_size)\n        font_spin.valueChanged.connect(self.update_fonts)\n\n        lbl = QLabel(\"Font Size:\")\n        lbl.setFont(QFont(\"Arial\", 12))\n\n        layout.addWidget(lbl)\n        layout.addWidget(font_spin)\n\n        reset_btn = QPushButton(\"Reset View\")\n        reset_btn.setFont(QFont(\"Arial\", 12))\n        reset_btn.clicked.connect(self.reset_view)\n        layout.addWidget(reset_btn)\n\n        main_layout.addLayout(layout)\n</code></pre>"},{"location":"reference/rionid/gui/plot/#rionid.gui.plot.CustomLegendItem","title":"<code>CustomLegendItem</code>","text":"<p>               Bases: <code>LegendItem</code></p> <p>Custom Legend with dynamic font sizing.</p> Source code in <code>src/rionid/gui/plot.py</code> <pre><code>class CustomLegendItem(pg.LegendItem):\n    \"\"\"Custom Legend with dynamic font sizing.\"\"\"\n    def __init__(self, font_size, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.font = QFont(\"Arial\", font_size)\n        self.brush = pg.mkBrush(255, 255, 255, 200) \n        self.pen = pg.mkPen('k', width=0.5)\n\n    def addItem(self, item, name):\n        label = pg.LabelItem(text=name, justify='left')\n        label.setFont(self.font)\n        super().addItem(item, name)\n\n    def updateFont(self, font_size):\n        self.font.setPointSize(font_size)\n\n    def paint(self, p, *args):\n        p.setPen(self.pen)\n        p.setBrush(self.brush)\n        p.drawRect(self.boundingRect())\n        super().paint(p, *args)\n</code></pre>"}]}